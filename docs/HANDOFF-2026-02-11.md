# Handoff: Sesja 2026-02-11

## Co zostalo zrobione w tej sesji

Poprzedni agent rozpoczal Krok 0 (Mock Data Seed) — ja dokonczylem go i zaimplementowalem Phase 3-6 w calosci. **Zmiany NIE sa jeszcze scommitowane.**

### Krok 0: Mock Data Seed ✅
Pliki:
- `src/lib/mock/seed-utils.ts` — generatory Message-ID, dat, UUID
- `src/lib/mock/seed-mailboxes.ts` — 3 skrzynki: Royal Residence, Sady Ursynow, Rzecznik Robyg
- `src/lib/mock/seed-emails.ts` — 64 emaile w 13 watkach, realistyczne PL content z PII
- `src/lib/mock/seed-data.ts` — seedMockData() + clearMockData(), idempotentny upsert
- `src/app/api/dev/seed/route.ts` — POST endpoint, admin-only
- `src/app/api/dev/clear/route.ts` — POST endpoint, admin-only

### Phase 3: Email Threading & Browsing ✅
Migracja: `supabase/migrations/20260211_03_01_email_threading.sql`
- Tabela `email_threads` (mailbox_id, subject_normalized, first/last_message_at, message_count, participant_addresses, status, avg_response_time_minutes)
- Nowe kolumny w `emails`: thread_id, subject_normalized, is_incoming, response_time_minutes
- Indeksy + RLS (admin only)

Algorytm: `src/lib/threading/thread-builder.ts`
- Union-Find grupowanie: In-Reply-To → References → Subject fallback (30 dni gap)
- Normalizacja tematu: Re:, Odp:, Fwd:, Fw:, PD:, VS:, SV:, AW: + [External] itp.
- Obliczanie: is_incoming, response_time_minutes, avg_response_time, thread status

API routes:
- `GET /api/threads` — lista watkow z paginacja i filtrami (mailboxId, status, search, from/to, sort)
- `GET /api/threads/[id]` — szczegoly watku z emailami chronologicznie
- `POST /api/threads/build` — buduj watki dla skrzynki (body: {mailboxId})

Typy: rozszerzone `src/types/email.ts` o EmailThread, EmailWithThread, ThreadStatus

UI komponenty (`src/components/threads/`):
- ThreadFilters.tsx — szukaj + filtry (status, daty)
- ThreadCard.tsx — karta watku z meta
- ThreadList.tsx — lista z paginacja + skeleton loading
- EmailMessage.tsx — pojedynczy email z kolorami kierunku i badge czasu odpowiedzi

Strony:
- `/email-analyzer/threads` — lista watkow z selektorem skrzynki + budowanie watkow
- `/email-analyzer/threads/[id]` — drill-down (chronologiczny widok emaili)

### Phase 4: AI Analysis + Anonimizacja ✅
Migracja: `supabase/migrations/20260211_04_01_ai_analysis.sql`
- 6 nowych tabel: ai_config, prompt_templates, evaluation_criteria, analysis_jobs, analysis_results, anonymization_map
- Wszystkie z RLS (admin only)

Biblioteki AI (`src/lib/ai/`):
- `anonymizer.ts` — regex: PESEL, telefony, emaile, IBAN, adresy, tablice rej. + kontekstowe imiona (Pan/Pani, podpisy). Klasa Anonymizer ze spojna mapa (ta sama osoba = ten sam identyfikator)
- `ai-provider.ts` — loadAIConfig() z Supabase, callAI() (OpenAI-compatible), szyfrowanie klucza
- `default-prompts.ts` — 7 sekcji: summary, communication_quality, response_time, case_status, contact_info, gdpr_compliance, recommendations. Wszystkie po polsku.

Hook: `src/hooks/useAnalysisJob.ts` — polling-driven (wzorzec identyczny jak useSyncJob)

API routes:
- `POST /api/analysis` — start analysis job
- `POST /api/analysis/process` — MAP: przetworz batch watkow (3 per batch), anonimizuj, wywolaj AI per sekcja
- `GET /api/analysis/status/[jobId]` — status joba
- `GET/POST /api/ai-config` — konfiguracja AI providera (klucz szyfrowany AES-256-GCM)
- `GET/POST /api/prompts` — zarzadzanie promptami (3-tier: default/global/per_report)

UI strony:
- `/email-analyzer/settings` — formularz: provider, model, klucz API, temperatura, max tokens
- `/email-analyzer/analyze` — selektor skrzynki, zakres dat, progress bar
- `/email-analyzer/prompts` — edytor promptow z lista sekcji

### Phase 5: Reports ✅
Migracja: `supabase/migrations/20260211_05_01_reports.sql`
- Tabele: reports, report_sections

API routes:
- `GET/POST /api/reports` — lista raportow / REDUCE: generuj raport z wynikow analizy (internal=7 sekcji, client=4)
- `GET/PATCH /api/reports/[id]` — szczegoly raportu / edycja sekcji markdown

Zaleznoci npm: `react-markdown`, `remark-gfm` (zainstalowane)

UI strony:
- `/email-analyzer/reports` — lista raportow + formularz generowania
- `/email-analyzer/reports/[id]` — podglad markdown (ReactMarkdown), edycja in-place, kopiuj do clipboard

### Phase 6: Dashboard ✅
API: `GET /api/dashboard` — KPI (skrzynki, emaile, watki, oczekujace, sr. czas odpowiedzi), mailboxes, recentReports

UI: `/email-analyzer/dashboard` — KPI tiles, podsumowanie skrzynek, ostatnie raporty, quick actions

### Sidebar zaktualizowany
Pelna nawigacja: Dashboard > Skrzynki > Watki > Analiza AI > Raporty > Prompty > Ustawienia AI

### Redirect
`/email-analyzer` teraz przekierowuje na `/email-analyzer/dashboard` (zamiast `/email-analyzer/mailboxes`)

---

## Stan git

**Zmiany NIE sa scommitowane.** Wszystko jest w working tree.

Zmodyfikowane istniejace pliki:
- `package.json` / `package-lock.json` (react-markdown, remark-gfm)
- `src/types/email.ts` (dodane EmailThread, EmailWithThread, ThreadStatus)
- `src/components/layout/Sidebar.tsx` (nowe pozycje nawigacji)
- `src/app/(hub)/email-analyzer/page.tsx` (redirect na /dashboard)

Nowe pliki: ~30 plikow (patrz `git status`)

---

## Co trzeba zrobic dalej

### 1. Commit zmian
Wszystko jest gotowe do commita. Sugestia:
```
feat(02-11): Phase 3-6 — threading, AI analysis, reports, dashboard

- Mock data seed (64 emails, 13 threads, 3 mailboxes)
- Email threading (Union-Find algorithm)
- AI analysis pipeline (anonymizer + OpenAI map-reduce)
- Reports (markdown preview, edit, clipboard export)
- Dashboard (KPI tiles, quick actions)
```

### 2. Zastosuj migracje SQL w Supabase
Kolejnosc:
1. `supabase/migrations/20260211_03_01_email_threading.sql`
2. `supabase/migrations/20260211_04_01_ai_analysis.sql`
3. `supabase/migrations/20260211_05_01_reports.sql`

Zastosuj przez SQL Editor w Supabase Dashboard (CLI jest zepsuty — patrz komentarz w pierwszej migracji).

### 3. Seed mock data
Po zastosowaniu migracji:
- Zaloguj sie jako admin
- Wywolaj `POST /api/dev/seed` (np. przez devtools / Postman / curl)
- Sprawdz dane w Supabase Table Editor

### 4. Zbuduj watki
- Wywolaj `POST /api/threads/build` z `{mailboxId: "<id-royal>"}` dla kazdej skrzynki
- Lub uzyj przycisku "Buduj watki" w UI `/email-analyzer/threads`

### 5. Skonfiguruj AI
- Przejdz do `/email-analyzer/settings`
- Wpisz klucz API OpenAI
- Wybierz model (domyslnie gpt-4o-mini)

### 6. Uruchom analize i raport
- `/email-analyzer/analyze` — wybierz skrzynke, kliknij "Rozpocznij analize"
- Po zakonczeniu: `/email-analyzer/reports` — "Generuj raport"

### 7. Eksport do .docx i .pdf (NIE ZAIMPLEMENTOWANY)
Plan przewidywal eksport do .docx (pakiet `docx`) i .pdf (`@react-pdf/renderer`). Na razie jest tylko kopiowanie markdown do clipboard. Pakiety NIE sa zainstalowane.

### 8. Kryteria oceny (evaluation_criteria) — tabela istnieje, UI NIE
Tabela w DB istnieje, ale nie ma dedykowanej strony UI do zarzadzania kryteriami. To niskopriorytetowe — kryteria moga byc uzywane w przyszlosci do scoringu.

### 9. API /api/reports POST — wymaga analysisJobId
Obecna implementacja POST /api/reports wymaga `analysisJobId` w body. Strona reports/page.tsx probuje go wywolac z `mailboxId`, co nie zadziala. Trzeba dodac:
- Albo endpoint do pobierania ostatniego completed analysis_job dla mailbox
- Albo zmienic POST /api/reports aby akceptowal `mailboxId` i sam znalazl ostatni job

To jest **bug do naprawienia** w nastepnej sesji.

---

## Architektura kluczowa

### Wzorzec polling-driven batch processing
Uzyty w sync i analysis:
1. Frontend wywoluje POST /api/[action] — tworzy job (status: pending)
2. Frontend w petli wywoluje POST /api/[action]/process z {jobId}
3. Backend przetwarza batch, zwraca {status, hasMore}
4. Frontend czeka BATCH_DELAY_MS i powtarza az hasMore=false
5. Hook zarzadza stanem (useRef dla cleanup, mountedRef)

### Anonimizacja
- Klasa Anonymizer jest per-watek (spójne mapowanie)
- anonymization_map zapisywany w DB — mozliwosc deanonimizacji przez admina
- Regex patterns dopasowane do polskich formatow (PESEL, telefony, ul./os./al.)

### Prompty 3-tier
1. default — z kodu (default-prompts.ts)
2. global — z DB (prompt_templates, tier='global') — nadpisuje default
3. per_report — z DB (tier='per_report', report_id) — nadpisuje global (NIE ZAIMPLEMENTOWANE w UI)

### Pliki krytyczne (istniejace wczesniej, reused)
- `src/lib/crypto/encrypt.ts` — AES-256-GCM szyfrowanie klucza API
- `src/lib/supabase/server.ts` — Supabase server client (cookies-based)
- `src/hooks/useSyncJob.ts` — wzorzec dla useAnalysisJob
- `src/contexts/AuthContext.tsx` — isAdmin, isLoading
