---
phase: 02-email-connection-fetching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/email.ts
  - src/lib/crypto/encrypt.ts
  - src/lib/email/graph-auth.ts
  - src/lib/email/graph-client.ts
  - .env.local
autonomous: true
user_setup:
  - service: azure-ad
    why: "ROPC flow wymaga Azure App Registration z Public Client enabled"
    env_vars:
      - name: AZURE_TENANT_ID
        source: "Azure Portal -> Microsoft Entra ID -> Overview -> Tenant ID"
      - name: AZURE_CLIENT_ID
        source: "Azure Portal -> App registrations -> [app] -> Application (client) ID"
      - name: ENCRYPTION_KEY
        source: "Wygeneruj 64-znakowy hex: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\""
    dashboard_config:
      - task: "Utworz App Registration z Public Client flows = YES, API permission Mail.Read (delegated)"
        location: "Azure Portal -> App registrations -> New registration"

must_haves:
  truths:
    - "Tabele mailboxes (z nowymi kolumnami), sync_jobs i emails istnieja w Supabase z RLS"
    - "Modul szyfrowania AES-256-GCM poprawnie szyfruje i deszyfruje tekst"
    - "Graph API auth zwraca access token dla podanych credentials (ROPC i client_credentials)"
    - "Graph client factory tworzy zainicjalizowanego klienta Microsoft Graph"
  artifacts:
    - path: "src/types/email.ts"
      provides: "TypeScript types dla mailbox, sync_job, email, credentials"
      min_lines: 40
    - path: "src/lib/crypto/encrypt.ts"
      provides: "AES-256-GCM encrypt/decrypt functions"
      exports: ["encrypt", "decrypt"]
    - path: "src/lib/email/graph-auth.ts"
      provides: "MSAL auth - ROPC + client_credentials"
      exports: ["getAccessToken"]
    - path: "src/lib/email/graph-client.ts"
      provides: "Microsoft Graph client factory"
      exports: ["createGraphClient"]
  key_links:
    - from: "src/lib/email/graph-auth.ts"
      to: "@azure/msal-node"
      via: "PublicClientApplication + ConfidentialClientApplication"
      pattern: "acquireTokenBy(UsernamePassword|ClientCredential)"
    - from: "src/lib/email/graph-client.ts"
      to: "src/lib/email/graph-auth.ts"
      via: "import getAccessToken"
      pattern: "getAccessToken"
    - from: "src/lib/crypto/encrypt.ts"
      to: "Node.js crypto"
      via: "createCipheriv/createDecipheriv"
      pattern: "aes-256-gcm"
---

<objective>
Fundament Phase 2: migracja bazy danych Supabase (mailboxes ALTER, sync_jobs CREATE, emails CREATE), typy TypeScript, modul szyfrowania AES-256-GCM, autentykacja Microsoft Graph API (ROPC + client_credentials) i fabryka klienta Graph.

Purpose: Wszystkie pozostale plany Phase 2 (API, UI, sync) zaleza od tych fundamentow -- tabel, typow, szyfrowania i dostepu do Graph API.
Output: Tabele DB z RLS, typy TS, encrypt/decrypt, Graph auth + client factory, zainstalowane npm dependencies.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-email-connection-fetching/02-RESEARCH.md
@.planning/phases/02-email-connection-fetching/02-CONTEXT.md
@src/types/index.ts
@src/lib/supabase/server.ts
@src/app/api/admin/users/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instalacja npm dependencies + typy TypeScript + modul szyfrowania AES-256-GCM</name>
  <files>
    package.json
    src/types/email.ts
    src/lib/crypto/encrypt.ts
  </files>
  <action>
1. Zainstaluj dependencies:
   ```
   npm install @azure/msal-node @microsoft/microsoft-graph-client @microsoft/microsoft-graph-types html-to-text
   npm install -D @types/html-to-text
   ```

2. Utworz `src/types/email.ts` z typami:
   - `ConnectionType = 'ropc' | 'client_credentials'`
   - `SyncStatus = 'never_synced' | 'syncing' | 'synced' | 'error'`
   - `SyncJobStatus = 'pending' | 'processing' | 'has_more' | 'completed' | 'failed'`
   - `SyncJobType = 'full' | 'delta'`
   - `Mailbox` interface (id, email_address, display_name, connection_type, tenant_id, client_id, sync_status, last_sync_at, total_emails, delta_link, created_at, updated_at)
   - `SyncJob` interface (id, mailbox_id, status, job_type, page_token, emails_fetched, emails_total_estimate, error_message, started_at, completed_at, created_at)
   - `Email` interface (id, mailbox_id, internet_message_id, graph_id, conversation_id, subject, from_address, from_name, to_addresses jako {address:string, name:string}[], cc_addresses, sent_at, received_at, body_text, body_html, has_attachments, header_message_id, header_in_reply_to, header_references jako string[], is_read, is_deleted, created_at)
   - `ROPCCredentials` interface (type:'ropc', tenantId, clientId, username, password)
   - `ClientCredentialsConfig` interface (type:'client_credentials', tenantId, clientId, clientSecret)
   - `MailboxCredentials = ROPCCredentials | ClientCredentialsConfig`
   - `MailboxFormData` interface (email_address, display_name, connection_type, tenant_id, client_id, username, password, client_secret)

3. Utworz `src/lib/crypto/encrypt.ts` -- wzorzec AES-256-GCM z Marketing Hub:
   - `encrypt(plaintext: string): string` -- format: `iv_base64:authTag_base64:ciphertext_base64`
   - `decrypt(encrypted: string): string`
   - Uzyj `crypto` (Node.js built-in), algorytm `aes-256-gcm`, IV 16 bytes
   - Klucz z `process.env.ENCRYPTION_KEY` (64 hex chars = 32 bytes)
   - Rzuc czytelny blad jesli ENCRYPTION_KEY nie jest ustawiony

WAZNE: NIE importuj `import * as crypto from 'crypto'` -- uzyj `import crypto from 'crypto'` (default import w ESM/Next.js).
  </action>
  <verify>
    npm run build -- powinno skompilowac bez bledow TypeScript.
    Sprawdz ze `src/types/email.ts` eksportuje Mailbox, SyncJob, Email, MailboxCredentials, MailboxFormData.
    Sprawdz ze `src/lib/crypto/encrypt.ts` eksportuje encrypt i decrypt.
  </verify>
  <done>
    Pakiety npm zainstalowane (package.json zawiera @azure/msal-node, @microsoft/microsoft-graph-client, @microsoft/microsoft-graph-types, html-to-text).
    Typy email domain zdefiniowane w src/types/email.ts.
    Modul szyfrowania AES-256-GCM gotowy w src/lib/crypto/encrypt.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migracja Supabase (mailboxes ALTER, sync_jobs CREATE, emails CREATE) + RLS</name>
  <files>
    (Supabase database via Management API)
  </files>
  <action>
1. Zbadaj istniejace tabele mailboxes, mailbox_credentials, emails w Supabase (uzyj Management API lub SQL query).
   - Supabase ref: zyqewiqtnxrhkaladoah
   - Supabase access token: (usunięty — użyj Supabase Dashboard)
   - Endpoint: POST https://zyqewiqtnxrhkaladoah.supabase.co/rest/v1/rpc/{function} lub SQL via Management API

2. Jesli istniejace tabele maja inne kolumny niz potrzebne -- uzyj ALTER TABLE ADD COLUMN IF NOT EXISTS (nie DROP).

3. Wykonaj SQL przez Supabase Management API (POST /v1/projects/zyqewiqtnxrhkaladoah/database/query):
   ```sql
   -- Mailboxes: dodaj kolumny jezeli brakuje
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS email_address TEXT;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS display_name TEXT;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS connection_type TEXT DEFAULT 'ropc';
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS credentials_encrypted TEXT;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS tenant_id TEXT;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS client_id TEXT;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS last_sync_at TIMESTAMPTZ;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS total_emails INTEGER DEFAULT 0;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS delta_link TEXT;
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS sync_status TEXT DEFAULT 'never_synced';
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW();
   ALTER TABLE mailboxes ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

   -- Sync jobs (nowa tabela)
   CREATE TABLE IF NOT EXISTS sync_jobs (
     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     mailbox_id UUID REFERENCES mailboxes(id) ON DELETE CASCADE,
     status TEXT NOT NULL DEFAULT 'pending',
     job_type TEXT NOT NULL DEFAULT 'full',
     page_token TEXT,
     emails_fetched INTEGER DEFAULT 0,
     emails_total_estimate INTEGER,
     error_message TEXT,
     started_at TIMESTAMPTZ,
     completed_at TIMESTAMPTZ,
     created_at TIMESTAMPTZ DEFAULT NOW()
   );

   -- Emails: sprawdz strukture i dostosuj
   -- Uzyj internet_message_id jako natural unique key per mailbox
   -- Dodaj kolumny dla Phase 3 threading (header_in_reply_to, header_references)
   ```
   Dostosuj emails table na podstawie tego co juz istnieje. Kluczowe kolumny: id, mailbox_id, internet_message_id, graph_id, conversation_id, subject, from_address, from_name, to_addresses (JSONB), cc_addresses (JSONB), sent_at, received_at, body_text, body_html, has_attachments, header_message_id, header_in_reply_to, header_references (TEXT[]), is_read, is_deleted, created_at. UNIQUE(mailbox_id, internet_message_id).

4. Indeksy:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_emails_mailbox_id ON emails(mailbox_id);
   CREATE INDEX IF NOT EXISTS idx_emails_received_at ON emails(received_at);
   CREATE INDEX IF NOT EXISTS idx_emails_conversation_id ON emails(conversation_id);
   CREATE INDEX IF NOT EXISTS idx_sync_jobs_mailbox_id ON sync_jobs(mailbox_id);
   CREATE INDEX IF NOT EXISTS idx_sync_jobs_status ON sync_jobs(status);
   ```

5. RLS -- service role full access (API routes uzywaja service role key):
   ```sql
   ALTER TABLE mailboxes ENABLE ROW LEVEL SECURITY;
   ALTER TABLE sync_jobs ENABLE ROW LEVEL SECURITY;
   ALTER TABLE emails ENABLE ROW LEVEL SECURITY;

   -- Service role bypasses RLS automatycznie w Supabase
   -- Dodaj policy dla authenticated users jesli potrzebne (read-only dla admina)
   CREATE POLICY "Admins can manage mailboxes" ON mailboxes FOR ALL
     USING (EXISTS (SELECT 1 FROM app_allowed_users WHERE user_id = auth.uid() AND role = 'admin'));
   CREATE POLICY "Admins can view sync_jobs" ON sync_jobs FOR ALL
     USING (EXISTS (SELECT 1 FROM app_allowed_users WHERE user_id = auth.uid() AND role = 'admin'));
   CREATE POLICY "Admins can view emails" ON emails FOR ALL
     USING (EXISTS (SELECT 1 FROM app_allowed_users WHERE user_id = auth.uid() AND role = 'admin'));
   ```

WAZNE: Supabase CLI jest broken -- uzyj Management API. Endpoint: `https://api.supabase.com/v1/projects/zyqewiqtnxrhkaladoah/database/query` z Bearer token (z Supabase Dashboard → Account → Access Tokens).
  </action>
  <verify>
    Wykonaj SQL query: `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('mailboxes', 'sync_jobs', 'emails')` -- powinno zwrocic 3 tabele.
    Sprawdz kolumny mailboxes: `SELECT column_name FROM information_schema.columns WHERE table_name = 'mailboxes'` -- powinno zawierac email_address, connection_type, credentials_encrypted, sync_status, delta_link.
    Sprawdz RLS: `SELECT tablename, policyname FROM pg_policies WHERE tablename IN ('mailboxes', 'sync_jobs', 'emails')`.
  </verify>
  <done>
    Tabele mailboxes (z nowymi kolumnami), sync_jobs i emails istnieja w Supabase.
    RLS wlaczone na wszystkich trzech tabelach z policies dla adminow.
    Indeksy utworzone na kluczowych kolumnach.
  </done>
</task>

<task type="auto">
  <name>Task 3: Microsoft Graph API auth (ROPC + client_credentials) i client factory</name>
  <files>
    src/lib/email/graph-auth.ts
    src/lib/email/graph-client.ts
    .env.local
  </files>
  <action>
1. Utworz `src/lib/email/graph-auth.ts`:
   - Importuj `PublicClientApplication` i `ConfidentialClientApplication` z `@azure/msal-node`
   - Importuj `MailboxCredentials` z `@/types/email`
   - Funkcja `getAccessToken(credentials: MailboxCredentials): Promise<string>`:
     - Dla `type === 'ropc'`: uzyj `pca.acquireTokenByUsernamePassword()` ze scopes `['https://graph.microsoft.com/Mail.Read']`
     - Dla `type === 'client_credentials'`: uzyj `cca.acquireTokenByClientCredential()` ze scopes `['https://graph.microsoft.com/.default']`
     - Authority: `https://login.microsoftonline.com/${credentials.tenantId}`
     - Rzuc czytelne bledy po polsku jesli auth sie nie uda
   - Funkcja `parseGraphAuthError(error: unknown): string` -- tlumacz kody AADSTS na polskie komunikaty:
     - AADSTS50076/50079: "Konto wymaga uwierzytelniania wieloskladnikowego (MFA)"
     - AADSTS50126: "Nieprawidlowy login lub haslo"
     - AADSTS50034: "Konto nie istnieje w tym tenancie"
     - AADSTS700016: "Nieprawidlowy Client ID"
     - AADSTS65001: "Brak uprawnienia Mail.Read"
     - Default: "Blad autentykacji: {message}"

2. Utworz `src/lib/email/graph-client.ts`:
   - Importuj `Client` z `@microsoft/microsoft-graph-client`
   - Funkcja `createGraphClient(accessToken: string): Client`:
     - `Client.init({ authProvider: (done) => done(null, accessToken) })`
   - Eksportuj jako named export

3. Dodaj do `.env.local` (na koncu pliku, z komentarzem):
   ```
   # Phase 2: Email Connection
   # ENCRYPTION_KEY=        # 64 hex chars - wygeneruj: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
   # AZURE_TENANT_ID=       # Microsoft 365 tenant ID
   # AZURE_CLIENT_ID=       # Azure App Registration client ID
   ```
   Te wartosci sa zakomentowane -- user musi je uzupelnic w ramach user_setup.

WAZNE: Nie przechowuj access tokenow w bazie (wygasaja po ~3600s). Pobieraj nowy token przed kazdym batch sync.
WAZNE: Authority URL musi uzywac tenantId, nie 'common' -- ROPC nie dziala z 'common'.
  </action>
  <verify>
    npm run build -- kompilacja bez bledow.
    Sprawdz ze `src/lib/email/graph-auth.ts` eksportuje getAccessToken i parseGraphAuthError.
    Sprawdz ze `src/lib/email/graph-client.ts` eksportuje createGraphClient.
    Import `@azure/msal-node` i `@microsoft/microsoft-graph-client` rozwiazuje sie poprawnie.
  </verify>
  <done>
    Graph auth obsluguje ROPC i client_credentials z polskimi komunikatami bledow.
    Graph client factory tworzy zainicjalizowanego klienta Microsoft Graph.
    Env vars dla Azure dodane do .env.local (zakomentowane, czekaja na konfiguracje usera).
  </done>
</task>

</tasks>

<verification>
1. `npm run build` przechodzi bez bledow
2. Tabele mailboxes, sync_jobs, emails istnieja w Supabase z poprawnymi kolumnami
3. RLS wlaczone na wszystkich tabelach z policies
4. Pliki src/types/email.ts, src/lib/crypto/encrypt.ts, src/lib/email/graph-auth.ts, src/lib/email/graph-client.ts istnieja i eksportuja poprawne funkcje/typy
5. Pakiety @azure/msal-node, @microsoft/microsoft-graph-client, html-to-text w package.json
</verification>

<success_criteria>
- npm run build przechodzi
- 3 tabele Supabase (mailboxes z nowymi kolumnami, sync_jobs, emails) z RLS i indeksami
- Typy email domain w src/types/email.ts
- AES-256-GCM encrypt/decrypt w src/lib/crypto/encrypt.ts
- Graph API auth (ROPC + client_credentials) w src/lib/email/graph-auth.ts
- Graph client factory w src/lib/email/graph-client.ts
- Nowe npm dependencies zainstalowane
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-connection-fetching/02-01-SUMMARY.md`
</output>
