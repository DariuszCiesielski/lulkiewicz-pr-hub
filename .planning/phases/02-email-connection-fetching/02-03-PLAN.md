---
phase: 02-email-connection-fetching
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/email/email-fetcher.ts
  - src/lib/email/email-parser.ts
  - src/app/api/sync/route.ts
  - src/app/api/sync/process/route.ts
  - src/app/api/sync/status/[jobId]/route.ts
autonomous: true

must_haves:
  truths:
    - "Sync job moze byc utworzony (POST /api/sync) i zwraca jobId"
    - "Process batch pobiera do 100 maili z Graph API i zapisuje je do Supabase"
    - "Po przetworzeniu batcha status job jest 'has_more' (jesli sa kolejne strony) lub 'completed'"
    - "Delta sync pobiera tylko nowe maile od ostatniego sync"
    - "Status sync job jest dostepny przez GET /api/sync/status/[jobId]"
    - "Maile sa parsowane: body HTML konwertowany na plaintext, naglowki threading wyodrebnione"
  artifacts:
    - path: "src/lib/email/email-fetcher.ts"
      provides: "Logika pobierania maili z Graph API (fetchMessagesPage, upsertEmails)"
      exports: ["fetchMessagesPage", "upsertEmails", "getMailboxMessageCount"]
      min_lines: 60
    - path: "src/lib/email/email-parser.ts"
      provides: "Parsowanie emaili (HTML to plaintext, extraction threading headers)"
      exports: ["parseEmailBody", "extractThreadingHeaders"]
      min_lines: 30
    - path: "src/app/api/sync/route.ts"
      provides: "POST start sync job"
      exports: ["POST"]
    - path: "src/app/api/sync/process/route.ts"
      provides: "POST process next batch"
      exports: ["POST"]
    - path: "src/app/api/sync/status/[jobId]/route.ts"
      provides: "GET sync job status"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/sync/process/route.ts"
      to: "src/lib/email/email-fetcher.ts"
      via: "fetchMessagesPage() + upsertEmails()"
      pattern: "fetchMessagesPage|upsertEmails"
    - from: "src/lib/email/email-fetcher.ts"
      to: "src/lib/email/graph-client.ts"
      via: "createGraphClient(token)"
      pattern: "createGraphClient"
    - from: "src/app/api/sync/process/route.ts"
      to: "src/lib/email/email-parser.ts"
      via: "parseEmailBody() + extractThreadingHeaders()"
      pattern: "parseEmailBody|extractThreadingHeaders"
    - from: "src/lib/email/email-parser.ts"
      to: "html-to-text"
      via: "convert() function"
      pattern: "convert\\("
---

<objective>
Silnik synchronizacji maili: API endpoints do tworzenia sync jobow, przetwarzania batchow (chunked po 100 maili), delta sync, oraz parsowanie emaili (HTML to plaintext + threading headers).

Purpose: Core pipeline pobierania tysiecy maili z Graph API z obsluga Vercel timeouts (max 60s per batch), zapisem do Supabase, i przygotowaniem danych do Phase 3 (threading).
Output: email-fetcher.ts, email-parser.ts, 3 API routes (start/process/status).
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-email-connection-fetching/02-RESEARCH.md
@.planning/phases/02-email-connection-fetching/02-01-SUMMARY.md
@src/types/email.ts
@src/lib/email/graph-auth.ts
@src/lib/email/graph-client.ts
@src/lib/crypto/encrypt.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Email parser (HTML to plaintext + threading headers extraction)</name>
  <files>
    src/lib/email/email-parser.ts
  </files>
  <action>
1. Utworz `src/lib/email/email-parser.ts`:

2. Funkcja `parseEmailBody(bodyContent: string | null, bodyContentType: string): { text: string; html: string | null }`:
   - Jesli bodyContentType === 'text': zwroc `{ text: bodyContent, html: null }`
   - Jesli bodyContentType === 'html':
     - Konwertuj z `html-to-text` (import `convert` from `html-to-text`)
     - Opcje: wordwrap: false, selectors: [skip img, skip style, skip script, links z nawiasami], preserveNewlines: true
     - Zwroc `{ text: converted, html: bodyContent }`
   - Jesli null: zwroc `{ text: '', html: null }`

3. Funkcja `extractThreadingHeaders(internetMessageHeaders: Array<{name: string, value: string}> | null): { messageId: string | null; inReplyTo: string | null; references: string[] }`:
   - Przejdz po headerach i wyciagnij:
     - `Message-ID` -> messageId
     - `In-Reply-To` -> inReplyTo
     - `References` -> references (split po spacjach, kazdy element to Message-ID)
   - Headers moga nie istniec -- zwroc null/[]

4. Funkcja `mapGraphMessageToEmail(msg: any, mailboxId: string): Partial<Email>`:
   - Mapuj pola z Graph API Message na nasz Email type:
     - internet_message_id: msg.internetMessageId
     - graph_id: msg.id
     - conversation_id: msg.conversationId
     - subject: msg.subject
     - from_address: msg.from?.emailAddress?.address
     - from_name: msg.from?.emailAddress?.name
     - to_addresses: msg.toRecipients?.map(r => ({address: r.emailAddress.address, name: r.emailAddress.name})) || []
     - cc_addresses: msg.ccRecipients?.map(...) || []
     - sent_at: msg.sentDateTime
     - received_at: msg.receivedDateTime
     - body_text/body_html: z parseEmailBody(msg.body?.content, msg.body?.contentType)
     - has_attachments: msg.hasAttachments || false
     - Threading: extractThreadingHeaders(msg.internetMessageHeaders)
     - is_read: msg.isRead || false
     - mailbox_id: mailboxId

WAZNE: `html-to-text` import: `import { convert } from 'html-to-text'`. Moze wymagac `// @ts-ignore` jesli typy nie resolwuja -- sprawdz czy @types/html-to-text jest zainstalowany.
WAZNE: internetMessageHeaders sa dostepne TYLKO jesli zostaly zarzadane w $select.
  </action>
  <verify>
    npm run build -- plik kompiluje bez bledow.
    Sprawdz ze eksportuje parseEmailBody, extractThreadingHeaders, mapGraphMessageToEmail.
  </verify>
  <done>
    Email parser konwertuje HTML na plaintext z html-to-text.
    Threading headers (Message-ID, In-Reply-To, References) sa wyodrebniane z internetMessageHeaders.
    Mapper mapuje Graph API Message na nasz Email type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Email fetcher (Graph API pagination, upsert, message count) + Sync API routes</name>
  <files>
    src/lib/email/email-fetcher.ts
    src/app/api/sync/route.ts
    src/app/api/sync/process/route.ts
    src/app/api/sync/status/[jobId]/route.ts
  </files>
  <action>
1. Utworz `src/lib/email/email-fetcher.ts`:

   Funkcja `getMailboxMessageCount(graphClient: Client, emailAddress: string): Promise<number>`:
   - `graphClient.api('/users/{email}/mailFolders/inbox').select('totalItemCount').get()`
   - Zwroc totalItemCount

   Funkcja `fetchMessagesPage(graphClient: Client, emailAddress: string, pageUrl: string | null): Promise<{messages: any[], nextLink: string | null}>`:
   - Jesli pageUrl (nextLink z poprzedniej strony): uzyj `graphClient.api(pageUrl).get()` -- NIE dodawaj $select/$top do nextLink!
   - Jesli null (pierwsza strona):
     ```
     graphClient
       .api(`/users/${emailAddress}/mailFolders/inbox/messages`)
       .top(100)
       .select('id,subject,from,toRecipients,ccRecipients,sentDateTime,receivedDateTime,body,bodyPreview,internetMessageId,conversationId,hasAttachments,internetMessageHeaders,isRead')
       .header('Prefer', 'outlook.body-content-type="text"')
       .orderby('receivedDateTime DESC')
       .get()
     ```
   - Zwroc `{ messages: response.value, nextLink: response['@odata.nextLink'] || null }`

   Funkcja `fetchDeltaPage(graphClient: Client, emailAddress: string, deltaLink: string | null): Promise<{messages: any[], nextLink: string | null, deltaLink: string | null, removedIds: string[]}>`:
   - Jesli deltaLink: uzyj go bezposrednio
   - Jesli null: uzyj `/users/${emailAddress}/mailFolders/inbox/messages/delta` z $top=100, $select, Prefer header
   - Parsuj removed messages (msg['@removed']) -- zbierz ich id do removedIds
   - Zwroc { messages (bez removed), nextLink: response['@odata.nextLink'], deltaLink: response['@odata.deltaLink'], removedIds }

   Funkcja `upsertEmails(adminClient: SupabaseClient, mailboxId: string, emails: Partial<Email>[]): Promise<number>`:
   - Upsert do tabeli emails z ON CONFLICT (mailbox_id, internet_message_id) DO UPDATE
   - Uzywaj adminClient (service role) do wstawiania
   - Zwroc liczbe wstawionych/zaktualizowanych rekordow
   - Filtruj emaile bez internet_message_id (pomijaj)

2. Utworz `src/app/api/sync/route.ts`:
   - `export const maxDuration = 30;`
   - **POST**: { mailboxId, type?: 'full' | 'delta' }
   - verifyAdmin()
   - Sprawdz czy mailbox istnieje
   - Sprawdz czy nie ma juz aktywnego sync job dla tego mailboxa (status IN ('pending', 'processing', 'has_more'))
   - Utworz sync_jobs record: { mailbox_id, status: 'pending', job_type: type || 'full', started_at: now() }
   - Zaktualizuj mailboxes.sync_status = 'syncing'
   - Zwroc { jobId: job.id, status: 'pending' }

3. Utworz `src/app/api/sync/process/route.ts`:
   - `export const maxDuration = 60;` -- Vercel timeout safety
   - **POST**: { jobId }
   - verifyAdmin()
   - Pobierz sync job z DB, sprawdz status (musi byc 'pending', 'processing', lub 'has_more')
   - Pobierz mailbox, odszyfruj credentials, pobierz token (getAccessToken)
   - Jesli pierwszy batch i typ 'full': pobierz estimated total (getMailboxMessageCount), zapisz w emails_total_estimate
   - Pobierz strone maili:
     - Dla 'full': fetchMessagesPage(graphClient, email, job.page_token)
     - Dla 'delta': fetchDeltaPage(graphClient, email, job.page_token || mailbox.delta_link)
   - Sparsuj maile: mapGraphMessageToEmail dla kazdego
   - Upsert do DB: upsertEmails()
   - Dla delta: obsluz removed messages (mark is_deleted = true)
   - Zaktualizuj sync job:
     - emails_fetched += nowe
     - status: 'has_more' jesli nextLink, 'completed' jesli nie
     - page_token: nextLink
     - completed_at jesli completed
   - Jesli completed:
     - Zaktualizuj mailbox: sync_status = 'synced', last_sync_at = now(), total_emails = count, delta_link (jesli delta)
   - Zwroc { status, fetched, totalFetched, estimatedTotal, hasMore }
   - Error handling: jesli blad Graph API (429 throttling), zapisz error_message i ustaw status = 'failed', sync_status mailboxa = 'error'
   - Safety timeout: mierz czas od startu, jesli > 50s -- przerwij, zapisz page_token, ustaw status 'has_more'

4. Utworz `src/app/api/sync/status/[jobId]/route.ts`:
   - **GET**: zwroc sync job z DB (status, emails_fetched, emails_total_estimate, error_message, started_at, completed_at)
   - verifyAdmin()

WAZNE: NIE dodawaj query params ($select, $top) do URL z @odata.nextLink -- parametry sa juz zakodowane.
WAZNE: Delay miedzy batchami NIE jest w API route (frontend robi delay). Ale dodaj retry z backoff dla 429.
WAZNE: Synchronizuj skrzynki SEKWENCYJNIE (nie rownolegle) -- rate limiting per tenant.
WAZNE: Uzyj adminClient (service role) do wszystkich DB operacji w sync.
  </action>
  <verify>
    npm run build -- wszystkie pliki kompiluja.
    API routes /api/sync (POST), /api/sync/process (POST), /api/sync/status/[jobId] (GET) istnieja.
    email-fetcher.ts eksportuje fetchMessagesPage, fetchDeltaPage, upsertEmails, getMailboxMessageCount.
  </verify>
  <done>
    Email fetcher obsluguje paginowane pobieranie z Graph API (100 per batch).
    Delta sync pobiera tylko nowe maile od ostatniego sync.
    Sync API: start job (POST /api/sync), process batch (POST /api/sync/process), status (GET /api/sync/status/[jobId]).
    Safety timeout (50s) zapobiega Vercel timeouts.
    Upsert z ON CONFLICT zapobiega duplikatom.
    Maile parsowane przez email-parser (body text + threading headers).
  </done>
</task>

</tasks>

<verification>
1. `npm run build` przechodzi bez bledow
2. email-parser.ts: HTML -> plaintext dziala, threading headers extracting dziala
3. email-fetcher.ts: pagination, upsert, delta, message count -- funkcje eksportowane
4. API routes: POST /api/sync, POST /api/sync/process, GET /api/sync/status/[jobId] -- kompiluja
5. Sync process obsluguje: full sync (all messages), delta sync (new only), throttling (429), timeout safety (50s)
</verification>

<success_criteria>
- Sync job moze byc utworzony i zwraca jobId
- Process batch pobiera 100 maili i upsertuje do DB
- Paginacja dziala (has_more -> kolejny batch)
- Delta sync uzywa deltaLink do pobrania tylko nowych maili
- Email parser konwertuje HTML na plaintext
- Threading headers (Message-ID, In-Reply-To, References) sa wyodrebniane
- Safety timeout 50s zapobiega Vercel timeouts
- Throttling 429 jest obslugiwany (error + retry info)
</success_criteria>

<output>
After completion, create `.planning/phases/02-email-connection-fetching/02-03-SUMMARY.md`
</output>
