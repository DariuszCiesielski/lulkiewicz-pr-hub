---
phase: 02.2-email-analyzer-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/threading/thread-builder.ts
  - src/types/email.ts
  - src/app/api/threads/build/route.ts
  - src/components/threads/ThreadCard.tsx
  - src/app/(hub)/email-analyzer/threads/page.tsx
  - src/app/(hub)/email-analyzer/analyze/page.tsx
  - src/app/(hub)/email-analyzer/reports/page.tsx
  - supabase/migrations/20260215_02_2_01_thread_intelligence.sql
autonomous: true

must_haves:
  truths:
    - "email_threads tabela ma kolumnę summary TEXT"
    - "Każdy wątek po budowaniu ma wypełnione pole summary (1-2 zdania)"
    - "Status wątku poprawnie rozróżnia: open, closed_positive, closed_negative, pending"
    - "ThreadCard wyświetla summary pod tematem wątku"
    - "Strony threads, analyze, reports zapamiętują ostatnio wybraną skrzynkę w localStorage"
  artifacts:
    - path: "supabase/migrations/20260215_02_2_01_thread_intelligence.sql"
      provides: "ALTER TABLE email_threads ADD COLUMN summary TEXT"
      contains: "summary"
    - path: "src/lib/threading/thread-builder.ts"
      provides: "Zaktualizowany builder z AI summary i ulepszonym statusem"
      exports: ["buildThreadsForMailbox"]
    - path: "src/components/threads/ThreadCard.tsx"
      provides: "Karta wątku z wyświetlanym summary"
---

<objective>
Thread Intelligence: dodanie AI-generowanych podsumowań wątków (1-2 zdania: czego dotyczy + jak się zakończył), ulepszenie detekcji statusu (open/closed_positive/closed_negative/pending) oraz zapamiętywanie ostatnio wybranej skrzynki w localStorage na wszystkich stronach email-analyzer.

Purpose: Użytkownik widzi na liście wątków od razu o czym jest każdy wątek i jaki jest jego aktualny stan.
Output: Migracja SQL, zaktualizowany thread-builder z logiką podsumowań, ThreadCard z summary, persisted mailbox selection.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-email-analyzer-quality/02.2-CONTEXT.md
@src/lib/threading/thread-builder.ts
@src/components/threads/ThreadCard.tsx
@src/app/(hub)/email-analyzer/threads/page.tsx
@src/app/(hub)/email-analyzer/analyze/page.tsx
@src/app/(hub)/email-analyzer/reports/page.tsx
@src/types/email.ts
@src/lib/ai/ai-provider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migracja SQL — kolumna summary + rozszerzenie statusu</name>
  <files>supabase/migrations/20260215_02_2_01_thread_intelligence.sql</files>
  <action>
Utwórz plik migracji SQL:

```sql
-- Phase 2.2: Thread Intelligence — summary + extended status
-- Uwaga: Wklej w Supabase Dashboard > SQL Editor

-- 1. email_threads: summary — krótki opis wątku (1-2 zdania)
ALTER TABLE email_threads ADD COLUMN IF NOT EXISTS summary TEXT;

-- 2. Aktualizacja statusu — dozwolone wartości rozszerzone
-- Obecne: open, closed, pending
-- Nowe: open, closed_positive, closed_negative, pending
-- (TEXT bez CHECK constraint — elastyczność)
COMMENT ON COLUMN email_threads.status IS 'Thread status: open, closed_positive, closed_negative, pending';
COMMENT ON COLUMN email_threads.summary IS 'AI-generated 1-2 sentence summary: what thread is about + how it ended';
```
  </action>
  <verify>Plik SQL istnieje, zawiera ALTER TABLE z summary.</verify>
  <done>Migracja SQL gotowa z kolumną summary.</done>
</task>

<task type="auto">
  <name>Task 2: Typ EmailThread — dodanie pola summary</name>
  <files>src/types/email.ts</files>
  <action>
W interfejsie EmailThread dodaj pole:
```typescript
summary?: string | null;
```

Jeśli istnieje enum/type dla statusu wątku, rozszerz o:
```typescript
type ThreadStatus = 'open' | 'closed_positive' | 'closed_negative' | 'pending';
```
  </action>
  <verify>`npx tsc --noEmit` — zero błędów.</verify>
  <done>Typ EmailThread zaktualizowany o summary.</done>
</task>

<task type="auto">
  <name>Task 3: thread-builder.ts — AI summary generowanie + ulepszona detekcja statusu</name>
  <files>src/lib/threading/thread-builder.ts</files>
  <action>
Po zbudowaniu wątków (istniejąca logika Union-Find), dodaj fazę generowania AI summary.

**3a. Import AI provider:**
```typescript
import { loadAIConfig, callAI } from '@/lib/ai/ai-provider';
```

**3b. Po utworzeniu email_threads, dla każdego wątku wygeneruj summary i status:**

Dla każdego wątku:
1. Pobierz maile wątku (już są w pamięci z budowania)
2. Przygotuj skrócony tekst (max 3000 znaków — pierwszy + ostatni mail)
3. Wyślij zapytanie AI z promptem:

```
System: Jesteś ekspertem od analizy korespondencji email administracji osiedli mieszkaniowych.

User: Przeanalizuj poniższy wątek email i odpowiedz w DOKŁADNIE takim formacie JSON:
{
  "summary": "1-2 zdania: czego dotyczy wątek + jak się zakończył lub na czym się zatrzymał",
  "status": "open | closed_positive | closed_negative | pending"
}

Zasady statusu:
- "closed_positive" — sprawa rozwiązana pozytywnie dla mieszkańca (naprawa wykonana, odpowiedź udzielona, problem rozwiązany)
- "closed_negative" — sprawa zakończona negatywnie (odmowa, brak rozwiązania, eskalacja bez efektu)
- "open" — sprawa w toku, wymaga dalszych działań
- "pending" — oczekuje na odpowiedź jednej ze stron

Wątek:
{{thread_text}}
```

4. Parsuj JSON response → update email_threads SET summary = ..., status = ...

**3c. Obsługa braku konfiguracji AI:**
Jeśli brak AI config (np. nie ustawiony klucz) — pomiń fazę summary, zostaw status jak dotychczas (algorytmiczny). Loguj warning.

**3d. Batch processing:**
Przetwarzaj wątki w batchach po 5 równolegle (Promise.allSettled), żeby nie przekroczyć rate limitu AI.

**3e. Raportuj wyniki:**
Do zwracanego obiektu result dodaj `summariesGenerated: number`.
  </action>
  <verify>
`npx tsc --noEmit` — zero błędów.
Sprawdź że buildThreadsForMailbox:
- Próbuje załadować AI config
- Generuje summary + status per wątek
- Graceful fallback gdy brak AI config
- Batch processing z limitem 5 równolegle
  </verify>
  <done>thread-builder.ts generuje AI summary i ulepsza status per wątek.</done>
</task>

<task type="auto">
  <name>Task 4: ThreadCard — wyświetlanie summary</name>
  <files>src/components/threads/ThreadCard.tsx</files>
  <action>
W komponencie ThreadCard, pod tematem wątku (subject), dodaj wyświetlanie summary:

```tsx
{thread.summary && (
  <p className="text-xs mt-1 line-clamp-2" style={{ color: 'var(--text-muted)' }}>
    {thread.summary}
  </p>
)}
```

Zaktualizuj też mapowanie statusów — dodaj nowe etykiety:
- `closed_positive` → "Zamknięty (pozytywnie)" z zielonym badge
- `closed_negative` → "Zamknięty (negatywnie)" z czerwonym badge
- `open` → "Otwarty" z niebieskim badge (jak dotychczas)
- `pending` → "Oczekujący" z żółtym badge (jak dotychczas)
  </action>
  <verify>Wizualnie: karta wątku pokazuje 1-2 zdania summary pod tematem.</verify>
  <done>ThreadCard wyświetla summary i rozróżnia zamknięty pozytywnie/negatywnie.</done>
</task>

<task type="auto">
  <name>Task 5: Persisted mailbox selection — localStorage na 3 stronach</name>
  <files>
    src/app/(hub)/email-analyzer/threads/page.tsx
    src/app/(hub)/email-analyzer/analyze/page.tsx
    src/app/(hub)/email-analyzer/reports/page.tsx
  </files>
  <action>
Na każdej z 3 stron (threads, analyze, reports), zmień logikę wyboru skrzynki:

**5a. Przy inicjalizacji — odczytaj z localStorage:**
```typescript
const [selectedMailboxId, setSelectedMailboxId] = useState<string>(() => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('ea-selected-mailbox') || '';
  }
  return '';
});
```

**5b. Przy zmianie — zapisz do localStorage:**
```typescript
const handleMailboxChange = (id: string) => {
  setSelectedMailboxId(id);
  localStorage.setItem('ea-selected-mailbox', id);
};
```

**5c. W useEffect ładowania skrzynek:**
Jeśli localStorage ma wartość i ta skrzynka istnieje na liście — użyj jej.
Jeśli nie — użyj pierwszej z listy i zapisz do localStorage.

Klucz localStorage: `ea-selected-mailbox` (współdzielony między stronami).
  </action>
  <verify>
Scenariusz: Wybierz skrzynkę na /threads → przejdź na /analyze → ta sama skrzynka jest wybrana.
Scenariusz: Opuść stronę → wróć → ta sama skrzynka jest wybrana.
  </verify>
  <done>Wszystkie 3 strony email-analyzer pamiętają ostatnio wybraną skrzynkę.</done>
</task>

</tasks>

<verification>
- [ ] Migracja SQL istnieje z kolumną summary
- [ ] EmailThread type ma pole summary
- [ ] thread-builder generuje AI summary per wątek
- [ ] thread-builder ustawia status: open/closed_positive/closed_negative/pending
- [ ] ThreadCard wyświetla summary pod tematem
- [ ] ThreadCard rozróżnia closed_positive/closed_negative wizualnie
- [ ] Strony threads/analyze/reports zapamiętują skrzynkę w localStorage
- [ ] `npx tsc --noEmit` przechodzi bez błędów
</verification>

<success_criteria>
1. Po zbudowaniu wątków każdy ma krótki opis (1-2 zdania) widoczny na liście
2. Statusy wątków poprawnie rozróżniają zamknięte pozytywnie/negatywnie
3. Wybrana skrzynka jest zapamiętywana między stronami i wizytami
4. Graceful fallback gdy brak konfiguracji AI
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-email-analyzer-quality/02.2-01-SUMMARY.md`
</output>
