---
phase: 02.2-email-analyzer-quality
plan: 03
type: execute
wave: 2
depends_on: ["02.2-01", "02.2-02"]
files_modified:
  - src/app/api/reports/route.ts
  - src/lib/ai/default-prompts.ts
  - src/lib/ai/report-synthesizer.ts
  - src/app/(hub)/email-analyzer/reports/[id]/page.tsx
  - src/lib/export/export-report-docx.ts
autonomous: false

must_haves:
  truths:
    - "POST /api/reports generuje raport syntetyczny (~5-15 stron) zamiast 400+ stron"
    - "Faza REDUCE wysyła zapytanie AI per sekcja do syntezy wyników z wielu wątków"
    - "Raport syntetyczny zawiera kluczowe wnioski ze wskazaniem konkretnych wątków"
    - "Raport szczegółowy (wątek po wątku) dostępny jako opcja"
    - "Eksport DOCX ma unikalną nazwę: typ_skrzynka_daty.docx"
    - "Podgląd raportu w przeglądarce ma poprawne formatowanie (nagłówki, separatory)"
    - "Synteza skaluje się niezależnie od liczby wątków (48 lub 1600) — raport zawsze ~5-15 stron"
    - "Dołączanie opisów (summary) wątków do raportu jest opcjonalne (checkbox)"
    - "Globalny prompt raportu przekazywany jako kontekst do każdego zapytania AI syntezy"
  artifacts:
    - path: "src/lib/ai/report-synthesizer.ts"
      provides: "Moduł syntezy raportów — AI agreguje wyniki per-thread w zwięzłe sekcje"
      exports: ["synthesizeReportSection"]
    - path: "src/app/api/reports/route.ts"
      provides: "Zaktualizowany endpoint z prawdziwą fazą REDUCE"
    - path: "src/lib/export/export-report-docx.ts"
      provides: "Eksport DOCX z unikalną nazwą pliku"
---

<objective>
Synthetic Reports: Fundamentalna zmiana fazy REDUCE — zamiast sklejania analiz wątek po wątku, AI syntetyzuje wyniki z wielu wątków w zwięzłe podsumowanie per sekcja. Domyślny raport syntetyczny (~5-15 stron), opcjonalny szczegółowy (jak dotychczas). Poprawa formatowania i nazw plików DOCX.

Purpose: Raport jest użytecznym narzędziem analitycznym (~5-15 stron), a nie zrzutem surowych danych (439 stron).
Output: report-synthesizer.ts, zaktualizowany POST /api/reports, poprawione formatowanie, unikalne nazwy DOCX.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-email-analyzer-quality/02.2-CONTEXT.md
@src/app/api/reports/route.ts
@src/lib/ai/default-prompts.ts
@src/lib/ai/ai-provider.ts
@src/lib/export/export-report-docx.ts
@src/app/(hub)/email-analyzer/reports/[id]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: report-synthesizer.ts — moduł syntezy AI per sekcja</name>
  <files>src/lib/ai/report-synthesizer.ts</files>
  <action>
Utwórz nowy moduł `src/lib/ai/report-synthesizer.ts`:

```typescript
import { callAI } from './ai-provider';
import type { AIConfig } from './ai-provider'; // lub odpowiedni typ

/**
 * REDUCE phase: AI syntetyzuje wyniki analizy z wielu wątków
 * w jedną zwięzłą sekcję raportu.
 *
 * Input: tablica per-thread analiz dla jednej sekcji (np. 48 wyników "summary")
 * Output: 1-2 strony syntetycznego podsumowania
 */

const SYNTHESIS_SYSTEM_PROMPT = `Jesteś ekspertem od tworzenia syntetycznych raportów z analizy komunikacji email administracji osiedli mieszkaniowych.

Twoim zadaniem jest zsyntetyzować analizy wielu wątków email w ZWIĘZŁE podsumowanie.

ZASADY:
- Pisz po polsku, profesjonalnym językiem raportowym
- Raport powinien mieć 1-3 stron per sekcja (NIE więcej)
- Wskazuj KLUCZOWE wnioski, trendy i problemy
- Podawaj konkretne przykłady z numerami/tematami wątków (np. "W wątku dot. awarii windy...")
- Używaj struktury: ogólne podsumowanie → kluczowe obserwacje → rekomendacje (jeśli dotyczy)
- NIE przepisuj treści wątków — syntetyzuj i agreguj
- Używaj formatowania Markdown: nagłówki ##, listy, **pogrubienia** dla kluczowych wniosków`;

interface SynthesisInput {
  sectionKey: string;
  sectionTitle: string;
  perThreadResults: Array<{
    threadSubject: string;
    content: string;
  }>;
  templateType: 'internal' | 'client';
  mailboxName: string;
  dateRange?: { from?: string; to?: string };
}

export async function synthesizeReportSection(
  aiConfig: AIConfig,
  input: SynthesisInput
): Promise<string> {
  const { sectionTitle, perThreadResults, templateType, mailboxName, dateRange } = input;

  // Przygotuj listę wyników per wątek (skróconą jeśli za długa)
  const threadSummaries = perThreadResults
    .map((r, i) => `### Wątek: ${r.threadSubject}\n${r.content}`)
    .join('\n\n---\n\n');

  // Ogranicz długość inputu (~100k znaków max, zostawiając miejsce na output)
  const maxInputLength = 100000;
  const truncatedSummaries = threadSummaries.length > maxInputLength
    ? threadSummaries.substring(0, maxInputLength) + '\n\n... (skrócono — zbyt wiele wątków)'
    : threadSummaries;

  const contextInfo = [
    `Skrzynka: ${mailboxName}`,
    dateRange?.from ? `Okres: ${dateRange.from} — ${dateRange.to || 'teraz'}` : null,
    `Liczba analizowanych wątków: ${perThreadResults.length}`,
    `Typ raportu: ${templateType === 'client' ? 'kliencki (zwięzły, profesjonalny)' : 'wewnętrzny (szczegółowy)'}`,
  ].filter(Boolean).join('\n');

  const userPrompt = `Sekcja raportu: **${sectionTitle}**

${contextInfo}

Poniżej znajdują się indywidualne analizy ${perThreadResults.length} wątków email dla tej sekcji. Zsyntetyzuj je w JEDNO zwięzłe podsumowanie (1-3 stron).

${templateType === 'client'
  ? 'UWAGA: To jest raport dla klienta (dewelopera) — pisz profesjonalnie, dyplomatycznie, z konstruktywnymi rekomendacjami.'
  : 'UWAGA: To jest raport wewnętrzny — możesz być bardziej bezpośredni i szczegółowy w ocenach.'}

---

${truncatedSummaries}`;

  const response = await callAI(aiConfig, SYNTHESIS_SYSTEM_PROMPT, userPrompt);
  return response.content;
}
```

Kluczowe:
- System prompt wymusza zwięzłość (1-3 stron per sekcja)
- Rozróżnia raport wewnętrzny (szczegółowy) vs kliencki (dyplomatyczny)
- Ogranicza input do 100k znaków (zabezpieczenie)
- Wskazuje na konkretne wątki jako przykłady

**Skalowalność dla dużej liczby wątków (>100):**
Jeśli per-thread results jest za dużo dla jednego prompta AI:
1. Podziel wyniki na batche po ~30 wątków
2. Syntetyzuj każdy batch osobno → uzyskaj ~30 mini-syntez
3. Meta-synteza: wyślij mini-syntezy do AI z promptem "Połącz te syntezy w jedno spójne podsumowanie"
To zapewnia że raport ma ~5-15 stron niezależnie od tego czy jest 48 czy 1600 wątków.

**Globalny prompt raportu:**
Dodaj parametr `globalContext` do SynthesisInput:
```typescript
globalContext?: string; // np. "Raport dotyczy administracji osiedla X, klient to deweloper Y"
```
Dołączaj go do user prompta jako kontekst przed wynikami wątków.

**Opcjonalne opisy wątków:**
Dodaj parametr `includeThreadSummaries: boolean` (domyślnie true).
Jeśli true, przy każdym wątku w syntezie dodaj jego AI summary z fazy budowania.
Jeśli false, podaj tylko treść analizy bez summary.
  </action>
  <verify>`npx tsc --noEmit` — zero błędów. Moduł eksportuje synthesizeReportSection.</verify>
  <done>report-synthesizer.ts gotowy z logiką syntezy AI.</done>
</task>

<task type="checkpoint">
  <name>Task 2: POST /api/reports — nowa faza REDUCE z AI syntezą</name>
  <files>src/app/api/reports/route.ts</files>
  <action>
Zmodyfikuj endpoint POST /api/reports:

**2a. Dodaj parametr `detailLevel` do body:**
```typescript
let body: {
  analysisJobId?: string;
  mailboxId?: string;
  templateType?: string;
  title?: string;
  detailLevel?: 'synthetic' | 'detailed'; // NOWE
};
```
Domyślnie: `'synthetic'`.

**2b. Dla `detailLevel === 'synthetic'` (domyślny):**

Zamiast obecnej logiki (sklejanie wątek po wątku), użyj AI syntezy:

```typescript
import { synthesizeReportSection } from '@/lib/ai/report-synthesizer';
import { loadAIConfig } from '@/lib/ai/ai-provider';

// Load AI config
const aiConfig = await loadAIConfig(adminClient);

// Dla każdej sekcji — syntetyzuj wyniki AI
for (const sectionKey of sectionsToInclude) {
  const promptDef = DEFAULT_PROMPTS.find(p => p.section_key === sectionKey);
  if (!promptDef) continue;

  const perThreadResults = (results || [])
    .filter(r => r.section_key === sectionKey && r.result_data?.content)
    .map(r => ({
      threadSubject: r.result_data.thread_subject || 'Bez tematu',
      content: r.result_data.content,
    }));

  let markdown: string;

  if (perThreadResults.length === 0) {
    markdown = '*Brak danych dla tej sekcji.*';
  } else if (perThreadResults.length === 1) {
    // Jeden wątek — nie trzeba syntetyzować
    markdown = perThreadResults[0].content;
  } else {
    // REDUCE: AI syntezuje wiele wątków
    markdown = await synthesizeReportSection(aiConfig, {
      sectionKey,
      sectionTitle: promptDef.title,
      perThreadResults,
      templateType: templateType as 'internal' | 'client',
      mailboxName,
      dateRange: {
        from: job.date_range_from,
        to: job.date_range_to,
      },
    });
  }

  sections.push({
    report_id: report.id,
    section_key: sectionKey,
    section_order: promptDef.section_order,
    title: promptDef.title,
    content_markdown: markdown,
    is_edited: false,
  });
}
```

**2c. Dla `detailLevel === 'detailed'`:**
Zachowaj obecną logikę (wątek po wątku) — to jest fallback na życzenie.

**2d. Tytuł raportu:**
Uwzględnij poziom szczegółowości:
```typescript
const title = body.title ||
  `Raport ${templateType === 'client' ? 'kliencki' : 'wewnętrzny'} ${detailLevel === 'detailed' ? '(szczegółowy) ' : ''}— ${mailboxName}`;
```

**UWAGA:** Synteza wymaga API call AI per sekcja (7 dla wewnętrznego, 4 dla klienckiego). Generowanie raportu syntetycznego potrwa ~30-60 sekund. Rozważ komunikat ładowania w UI.
  </action>
  <verify>
Test: POST /api/reports z detailLevel=synthetic → raport powinien mieć ~5-15 stron zamiast 400+.
Test: POST /api/reports z detailLevel=detailed → raport jak dotychczas (wątek po wątku).
  </verify>
  <done>POST /api/reports z prawdziwą fazą REDUCE — AI syntetyzuje wyniki.</done>
</task>

<task type="auto">
  <name>Task 3: reports/page.tsx — opcja synthetic vs detailed + komunikat ładowania</name>
  <files>src/app/(hub)/email-analyzer/reports/page.tsx</files>
  <action>
**3a. Dodaj wybór poziomu szczegółowości w formularzu generowania:**
```tsx
<div className="flex flex-col gap-1">
  <label className="text-xs font-medium" style={{ color: 'var(--text-muted)' }}>
    Poziom szczegółowości
  </label>
  <select value={detailLevel} onChange={e => setDetailLevel(e.target.value)}>
    <option value="synthetic">Syntetyczny (~5-15 stron)</option>
    <option value="detailed">Szczegółowy (wątek po wątku)</option>
  </select>
</div>
```

**3b. Dodaj komunikat ładowania podczas generowania:**
Przy `isGenerating=true` wyświetlaj:
"Generowanie raportu syntetycznego... AI syntetyzuje wyniki z X wątków. To może potrwać do minuty."

**3c. Po wygenerowaniu — od razu przekieruj na podgląd (bez przeskoków):**
Upewnij się że `router.push(...)` jest jednorazowy i nie ma podwójnego renderowania.
  </action>
  <verify>Formularz zawiera dropdown synthetic/detailed. Komunikat ładowania wyświetla się przy generowaniu.</verify>
  <done>UI raportów z wyborem poziomu szczegółowości.</done>
</task>

<task type="auto">
  <name>Task 4: Formatowanie podglądu raportu w przeglądarce</name>
  <files>src/app/(hub)/email-analyzer/reports/[id]/page.tsx</files>
  <action>
**4a. Popraw rendering Markdown:**
Upewnij się że sekcje mają:
- Wyraźne nagłówki z wizualnym separatorem między sekcjami
- Spis treści na górze (lista sekcji z anchor linkami)
- Odpowiednie odstępy między paragrafami
- Stylowanie list (bullet points, numerowane)
- Pogrubienia i kursywa

**4b. Dodaj spis treści:**
```tsx
<nav className="mb-6 p-4 rounded-lg border" style={{ borderColor: 'var(--border-primary)', backgroundColor: 'var(--bg-secondary)' }}>
  <h3 className="text-sm font-medium mb-2" style={{ color: 'var(--text-primary)' }}>Spis treści</h3>
  <ol className="space-y-1">
    {sections.map(s => (
      <li key={s.section_key}>
        <a href={`#section-${s.section_key}`} className="text-sm hover:underline" style={{ color: 'var(--accent-primary)' }}>
          {s.title}
        </a>
      </li>
    ))}
  </ol>
</nav>
```

**4c. Każda sekcja z anchor ID:**
```tsx
<section id={`section-${section.section_key}`} className="mb-8">
```
  </action>
  <verify>Podgląd raportu ma spis treści, czytelne nagłówki i formatowanie.</verify>
  <done>Podgląd raportu sformatowany z nawigacją.</done>
</task>

<task type="auto">
  <name>Task 5: export-report-docx.ts — unikalne nazwy plików</name>
  <files>src/lib/export/export-report-docx.ts</files>
  <action>
Zmień logikę generowania nazwy pliku DOCX:

```typescript
function generateDocxFilename(report: {
  template_type: string;
  title: string;
  date_range_from?: string | null;
  date_range_to?: string | null;
  created_at: string;
}): string {
  const type = report.template_type === 'client' ? 'kliencki' : 'wewnetrzny';
  const date = new Date(report.created_at).toISOString().split('T')[0]; // YYYY-MM-DD

  // Sanitize title for filename
  const safeTitle = (report.title || 'raport')
    .replace(/[^a-zA-Z0-9ąćęłńóśźżĄĆĘŁŃÓŚŹŻ\s-]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 60);

  let filename = `Raport_${type}_${date}`;

  if (report.date_range_from) {
    const from = report.date_range_from.split('T')[0];
    const to = report.date_range_to?.split('T')[0] || 'teraz';
    filename += `_${from}_${to}`;
  }

  return `${filename}.docx`;
}
```

Przykłady nazw:
- `Raport_wewnetrzny_2026-02-15_2026-01-01_2026-01-31.docx`
- `Raport_kliencki_2026-02-15_2026-01-01_2026-01-31.docx`
  </action>
  <verify>Eksport DOCX tworzy plik z unikalną nazwą zawierającą typ i daty.</verify>
  <done>Nazwy plików DOCX unikalne per typ raportu i zakres dat.</done>
</task>

</tasks>

<verification>
- [ ] POST /api/reports z detailLevel=synthetic generuje raport ~5-15 stron
- [ ] POST /api/reports z detailLevel=detailed generuje raport jak dotychczas
- [ ] AI syntezuje wyniki per sekcja (nie skleja wątek po wątku)
- [ ] Raport syntetyczny zawiera kluczowe wnioski ze wskazaniem wątków
- [ ] UI ma dropdown synthetic/detailed z komunikatem ładowania
- [ ] Podgląd raportu ma spis treści i poprawne formatowanie
- [ ] Eksport DOCX ma unikalną nazwę: typ_data_zakres.docx
- [ ] Nawigacja po wygenerowaniu: jedno przekierowanie na podgląd
- [ ] `npx tsc --noEmit` przechodzi bez błędów
</verification>

<success_criteria>
1. Domyślny raport syntetyczny ma ~5-15 stron (nie 400+)
2. AI tworzy zwięzłe podsumowania ze wskazaniem kluczowych wątków
3. Raport szczegółowy nadal dostępny na życzenie
4. Formatowanie czytelne w przeglądarce i DOCX
5. Nazwy plików DOCX rozróżniają typy raportów
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-email-analyzer-quality/02.2-03-SUMMARY.md`
</output>
