---
phase: 10-ai-sentiment-analysis
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/app/api/fb/analysis/route.ts
  - src/app/api/fb/analysis/process/route.ts
  - src/app/api/fb/analysis/pause/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/fb/analysis tworzy fb_analysis_jobs row i zwraca jobId + totalPosts"
    - "POST /api/fb/analysis/process przetwarza batch 5 postow rownolegle z callAI i structured JSON output"
    - "Krotkie posty (<20 znakow) sa pomijane i oznaczane jako nieistotne bez wywolania AI"
    - "Posty z sentiment IS NOT NULL sa domyslnie pomijane (skip analyzed)"
    - "POST /api/fb/analysis/pause obsluguje pause/resume/cancel"
    - "Wyniki analizy sa zapisywane bezposrednio na kolumnach fb_posts (sentiment, relevance_score, ai_snippet, ai_categories)"
  artifacts:
    - path: "src/app/api/fb/analysis/route.ts"
      provides: "POST create job + GET list jobs"
      exports: ["POST", "GET"]
    - path: "src/app/api/fb/analysis/process/route.ts"
      provides: "POST batch processing with AI"
      exports: ["POST"]
      contains: "Promise.allSettled"
    - path: "src/app/api/fb/analysis/pause/route.ts"
      provides: "POST pause/resume/cancel"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/fb/analysis/process/route.ts"
      to: "src/lib/ai/ai-provider.ts"
      via: "callAI with responseFormat"
      pattern: "callAI.*FB_POST_ANALYSIS_SCHEMA"
    - from: "src/app/api/fb/analysis/process/route.ts"
      to: "src/lib/fb/fb-analysis-prompt.ts"
      via: "imports prompt + schema + buildFbUserPrompt"
      pattern: "buildFbUserPrompt"
    - from: "src/app/api/fb/analysis/process/route.ts"
      to: "src/lib/fb/fb-keywords.ts"
      via: "imports loadKeywords + matchKeywords"
      pattern: "loadKeywords.*matchKeywords"
    - from: "src/app/api/fb/analysis/route.ts"
      to: "fb_analysis_jobs table"
      via: "insert job row"
      pattern: "fb_analysis_jobs.*insert"
---

<objective>
Stworzenie 3 API routes do analizy AI postow FB: tworzenie jobow, batch processing z structured JSON output i pause/resume. Kazdy post analizowany indywidualnie (1 AI call), 5 postow rownolegle per request, wyniki zapisywane bezposrednio na fb_posts.

Purpose: Te API routes sa core engine Phase 10 — bez nich frontend nie moze uruchomic analizy. Pattern identyczny jak email analyzer (polling-driven batch processing) ale prostszy (wyniki na fb_posts, nie w osobnej tabeli).
Output: 3 pliki route.ts w src/app/api/fb/analysis/ — pelny backend AI analysis pipeline
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-ai-sentiment-analysis/10-RESEARCH.md
@.planning/phases/10-ai-sentiment-analysis/10-01-SUMMARY.md
@src/app/api/analysis/route.ts
@src/app/api/analysis/process/route.ts
@src/app/api/analysis/pause/route.ts
@src/lib/ai/ai-provider.ts
@src/lib/fb/fb-analysis-prompt.ts
@src/lib/fb/fb-keywords.ts
@src/types/fb.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: POST/GET /api/fb/analysis (create job + list jobs)</name>
  <files>src/app/api/fb/analysis/route.ts</files>
  <action>
Stworz `src/app/api/fb/analysis/route.ts` na wzor `src/app/api/analysis/route.ts` ale uproszczony (bez demo-scope, bez cost enrichment w v1).

**POST /api/fb/analysis** — tworzy nowy job analizy:
1. `verifyAdmin()` z `@/lib/api/admin` (NIE verifyScopedAdminAccess — FB nie ma demo scope)
2. Body: `{ groupId: string, forceReanalyze?: boolean }`
3. Walidacja: `groupId` wymagany
4. Sprawdz czy grupa istnieje i nie jest deleted: `fb_groups` WHERE id = groupId AND deleted_at IS NULL
5. Sprawdz AI config: `ai_config` WHERE is_active = true. Jesli brak: 400 "Brak konfiguracji AI"
6. Sprawdz brak aktywnego joba: `fb_analysis_jobs` WHERE group_id = groupId AND status IN ('pending', 'running', 'paused'). Jesli istnieje: 409 "Analiza juz trwa"
7. Policz posty do analizy:
   - Jesli `forceReanalyze = true`: COUNT fb_posts WHERE group_id = groupId AND content IS NOT NULL
   - Jesli `forceReanalyze = false` (default): COUNT fb_posts WHERE group_id = groupId AND content IS NOT NULL AND sentiment IS NULL
   - Jesli 0 postow: 400 "Brak postow do analizy"
8. INSERT fb_analysis_jobs: `{ group_id, status: 'pending', total_posts: count, analyzed_posts: 0, progress: 0, started_at: now() }`
9. Return: `{ jobId, totalPosts, forceReanalyze }`

**GET /api/fb/analysis** — lista jobow:
1. `verifyAdmin()`
2. Query param: `?groupId=uuid` (opcjonalny)
3. SELECT z fb_analysis_jobs, order by created_at desc, limit 10
4. Jesli groupId — filtruj po group_id
5. Enrich: dolacz group name z fb_groups (LEFT JOIN lub subquery)
6. Return: `{ jobs: [...] }`
  </action>
  <verify>
  - `npx tsc --noEmit` przechodzi
  - Plik `src/app/api/fb/analysis/route.ts` istnieje z eksportami POST i GET
  - `grep "fb_analysis_jobs" src/app/api/fb/analysis/route.ts` potwierdza interakcje z tabela
  </verify>
  <done>
  - POST /api/fb/analysis tworzy job w fb_analysis_jobs, waliduje grupe/AI config/brak aktywnego joba, zwraca jobId
  - GET /api/fb/analysis zwraca liste ostatnich jobow z group name
  - forceReanalyze parametr kontroluje czy pomijac juz przeanalizowane posty
  </done>
</task>

<task type="auto">
  <name>Task 2: POST /api/fb/analysis/process + POST /api/fb/analysis/pause</name>
  <files>
    src/app/api/fb/analysis/process/route.ts
    src/app/api/fb/analysis/pause/route.ts
  </files>
  <action>
**process/route.ts** — batch processing na wzor `/api/analysis/process/route.ts`:

1. `export const maxDuration = 60;`
2. Stale: `POSTS_PER_REQUEST = 5`, `MIN_CONTENT_LENGTH = 20`
3. `verifyAdmin()`, body: `{ jobId }`
4. Load job z fb_analysis_jobs. Jesli completed/failed — return status. Jesli paused — return paused + hasMore: false.
5. Jesli status = 'pending' — update na 'running'
6. Load AI config: `loadAIConfig(adminClient)`
7. Load group z fb_groups (potrzebne: name, developer, ai_instruction)
8. Resolve prompt:
   - Sprawdz prompt_templates WHERE section_key = '_fb_post_analysis' AND is_active = true AND tier = 'global'
   - Jesli jest override w DB — uzyj go. Jesli nie — uzyj domyslnych z fb-analysis-prompt.ts
   - Zbierz extra instructions: developer_instruction (z fb_settings, klucz `developer_instruction:{group.developer}`) + group.ai_instruction
9. Load keywords: `loadKeywords(adminClient, job.group_id)`
10. Get next batch unanalyzed posts:
    - Sprawdz job metadata (czy forceReanalyze) — jesli tak, SELECT WHERE group_id AND content IS NOT NULL, ale uzyj offsetu opartego na analyzed_posts
    - Jesli nie forceReanalyze: SELECT WHERE group_id AND content IS NOT NULL AND sentiment IS NULL, limit POSTS_PER_REQUEST
    - Sortuj: `posted_at DESC`
11. Pre-filter: posty z content.length < MIN_CONTENT_LENGTH -> oznacz jako nieistotne:
    ```
    UPDATE fb_posts SET sentiment = 'neutral', relevance_score = 0,
      ai_snippet = '(Post zbyt krotki do analizy)', ai_categories = '["inne"]'::jsonb
    WHERE id IN (shortPostIds)
    ```
    UWAGA: `ai_categories` w DB jest typu `text[]` (PostgreSQL array). Uzyj formatu odpowiedniego dla Supabase: `ai_categories: ['inne']`
12. Procesuj pozostale posty rownolegle via `Promise.allSettled`:
    ```typescript
    await Promise.allSettled(toAnalyze.map(async (post) => {
      const keywordMatches = matchKeywords(post.content, keywords);
      const userPrompt = buildFbUserPrompt(post, group.name, keywordMatches, extraInstructions);
      const response = await callAI(aiConfig, systemPrompt, userPrompt, FB_POST_ANALYSIS_SCHEMA);
      const result: FbPostAnalysisResult = JSON.parse(response.content);

      // Keyword boost
      let adjustedScore = result.relevance_score;
      if (keywordMatches.length > 0 && adjustedScore < 10) {
        adjustedScore = Math.min(10, adjustedScore + Math.min(keywordMatches.length, 2));
      }

      // Clamp relevance_score 0-10 (safety — strict mode may not enforce min/max)
      adjustedScore = Math.max(0, Math.min(10, adjustedScore));

      await adminClient.from('fb_posts').update({
        sentiment: result.sentiment,
        relevance_score: adjustedScore,
        ai_snippet: result.ai_snippet,
        ai_categories: result.categories,
      }).eq('id', post.id);
    }));
    ```
13. Update job progress:
    - Policz nowo przetworzone (batch size z pre-filter + AI)
    - Inkrement analyzed_posts
    - Oblicz progress = round(analyzed_posts / total_posts * 100)
    - Jesli brak wiecej postow: status = 'completed', completed_at = now()
14. Return: `{ status, analyzedPosts, totalPosts, hasMore }`
15. Error handling: catch na calym try block -> update job status = 'failed' + error_message

**pause/route.ts** — pause/resume/cancel:
1. `verifyAdmin()`, body: `{ jobId, action: 'pause' | 'resume' | 'cancel' }`
2. Load job z fb_analysis_jobs
3. Pause: status musi byc 'running' lub 'pending' -> update 'paused'
4. Resume: status musi byc 'paused' -> update 'running'
5. Cancel: status musi byc 'running'/'pending'/'paused' -> update 'failed' z error_message 'Anulowano przez uzytkownika'
6. Return: `{ status, analyzedPosts, totalPosts }`

WAZNE:
- NIE importuj z demo-scope — FB routes uzywaja verifyAdmin() bezposrednio
- `ai_categories` w fb_posts to `text[]` w PostgreSQL — Supabase akceptuje JavaScript array bezposrednio
- Loguj bledy AI per post ale NIE failuj calego joba (like scrape upsert errors)
  </action>
  <verify>
  - `npx tsc --noEmit` przechodzi
  - `grep "Promise.allSettled" src/app/api/fb/analysis/process/route.ts` potwierdza parallel processing
  - `grep "callAI" src/app/api/fb/analysis/process/route.ts` potwierdza wywolanie AI
  - `grep "FB_POST_ANALYSIS_SCHEMA" src/app/api/fb/analysis/process/route.ts` potwierdza structured output
  - `grep "pause.*resume.*cancel" src/app/api/fb/analysis/pause/route.ts` potwierdza obsluge 3 akcji
  </verify>
  <done>
  - POST /api/fb/analysis/process przetwarza 5 postow rownolegle, pre-filteruje krotkie, uzywa structured JSON, zapisuje wyniki na fb_posts, zwraca progress
  - POST /api/fb/analysis/pause obsluguje pause/resume/cancel z walidacja stanu
  - Keyword boost +1-2 punkty relevance_score przy trafieniu
  - Posty z sentiment IS NOT NULL sa pomijane (chyba ze forceReanalyze)
  - Bledy AI logowane ale nie failuja calego joba
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` — zero bledow
- 3 pliki route.ts istnieja w `src/app/api/fb/analysis/`, `src/app/api/fb/analysis/process/`, `src/app/api/fb/analysis/pause/`
- process route importuje i uzywa: callAI, FB_POST_ANALYSIS_SCHEMA, buildFbUserPrompt, loadKeywords, matchKeywords
- process route ma `export const maxDuration = 60`
- process route uzywa `Promise.allSettled` do parallel processing
- pause route obsluguje 3 akcje: pause, resume, cancel
</verification>

<success_criteria>
- API routes sie kompiluja i eksportuja prawidlowe handlery HTTP
- Pattern batch processing jest identyczny jak w email analyzer: polling-driven, statusy, progress tracking
- Structured JSON output gwarantuje valid response z AI (no manual parsing/retry needed)
- Pre-filter eliminuje krotkie posty bez marnowania AI calls
- Keyword boost dziala na poziomie process route (nie w prompcie)
</success_criteria>

<output>
After completion, create `.planning/phases/10-ai-sentiment-analysis/10-02-SUMMARY.md`
</output>
