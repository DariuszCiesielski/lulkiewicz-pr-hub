---
phase: 08-group-management
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/api/fb-groups/route.ts
  - src/app/api/fb-groups/[id]/route.ts
  - src/app/api/fb-groups/bulk/route.ts
  - src/app/api/fb-groups/developers/route.ts
  - src/app/api/fb-settings/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/fb-groups zwraca liste grup (bez soft-deleted) z filtrami developer i status"
    - "POST /api/fb-groups tworzy grupe (single) lub grupy (bulk z URL-ami)"
    - "PATCH /api/fb-groups/[id] aktualizuje grupe, DELETE soft-deletuje"
    - "PATCH /api/fb-groups/bulk obsluguje bulk set_status, set_developer, soft_delete"
    - "GET /api/fb-groups/developers zwraca distinct developers dla autosuggest"
    - "POST /api/fb-settings zapisuje zaszyfrowane credentiale, GET zwraca boolean flagi (nie wartosci)"
  artifacts:
    - path: "src/app/api/fb-groups/route.ts"
      provides: "GET lista + POST create single/bulk"
      exports: ["GET", "POST"]
    - path: "src/app/api/fb-groups/[id]/route.ts"
      provides: "GET detail + PATCH update + DELETE soft-delete"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/app/api/fb-groups/bulk/route.ts"
      provides: "PATCH bulk operations"
      exports: ["PATCH"]
    - path: "src/app/api/fb-groups/developers/route.ts"
      provides: "GET distinct developers"
      exports: ["GET"]
    - path: "src/app/api/fb-settings/route.ts"
      provides: "GET settings flags + POST save encrypted settings"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/fb-groups/route.ts"
      to: "@/lib/api/admin"
      via: "import verifyAdmin, getAdminClient"
      pattern: "import.*verifyAdmin.*getAdminClient.*from.*@/lib/api/admin"
    - from: "src/app/api/fb-settings/route.ts"
      to: "@/lib/crypto/encrypt"
      via: "import encrypt"
      pattern: "import.*encrypt.*from.*@/lib/crypto/encrypt"
    - from: "src/app/api/fb-groups/route.ts"
      to: "supabase fb_groups table"
      via: "adminClient.from('fb_groups')"
      pattern: "\\.from\\('fb_groups'\\)"
---

<objective>
API routes dla zarzadzania grupami FB i ustawien Apify. 5 endpointow pokrywajacych caly CRUD, bulk ops, autosuggest developers i encrypted settings.

Purpose: Frontend (Plan 03-04) potrzebuje API do komunikacji z DB. Szyfrowanie credentiali (encrypt/decrypt) musi byc po stronie serwera.
Output: 5 plikow API routes gotowych do konsumpcji przez UI.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-group-management/08-RESEARCH.md
@src/lib/api/admin.ts
@src/lib/crypto/encrypt.ts
@src/app/api/mailboxes/route.ts
@src/types/fb.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: CRUD API routes dla fb-groups</name>
  <files>
    src/app/api/fb-groups/route.ts
    src/app/api/fb-groups/[id]/route.ts
    src/app/api/fb-groups/developers/route.ts
  </files>
  <action>
Utworz 3 pliki API routes wedlug wzorca z mailboxes (verifyAdmin + getAdminClient):

**1. `src/app/api/fb-groups/route.ts` — GET (list) + POST (create)**

GET:
- `verifyAdmin()` guard
- Query params: `?developer=X` i `?status=active|paused` (opcjonalne filtry)
- SELECT explicite kolumny (NIGDY `*`, NIGDY `cookies_encrypted`):
  ```
  id, name, facebook_url, developer, status, last_scraped_at,
  total_posts, ai_instruction, apify_actor_id, created_at, updated_at
  ```
- OBOWIAZKOWY filtr: `.is('deleted_at', null)` (wyklucz soft-deleted)
- Order: `.order('developer', { ascending: true, nullsFirst: false }).order('name', { ascending: true })`
- Wzbogac o `relevant_posts` (count fb_posts per group_id) i `has_custom_cookies` (boolean: cookies_encrypted IS NOT NULL)
- Aby policzyc relevant_posts efektywnie: osobne zapytanie `.from('fb_posts').select('group_id').in('group_id', groupIds)` i policz recznie w JS (bez `.gte('relevance_score', ...)` — w tej fazie posty nie maja jeszcze score, po prostu policz wszystkie posty per group)
- Zwraca: `FbGroupEnriched[]`

POST:
- `verifyAdmin()` guard
- Body: `{ name, facebook_url, developer?, ai_instruction? }` dla single create
- Body: `{ urls: string[], developer? }` dla bulk create (z pliku URL-ow)
- Rozroznienie: jesli body zawiera `urls` (array) -> bulk, inaczej -> single
- Walidacja:
  - Single: `name` required, `facebook_url` required + walidacja regex (`facebook.com/groups/`)
  - Bulk: `urls` required, max 100 items, waliduj kazdy URL, zwroc `{ created: N, errors: [{line, url, reason}] }`
- Single: insert + `.select(GROUP_SELECT_COLUMNS).single()`, zwroc 201
- Bulk: dla kazdego valid URL insert z `name` = ostatni segment URL-a (po `/groups/`), `developer` z body, status = 'active'. Uzyj `adminClient.from('fb_groups').insert(records)` (batch insert). Zwroc `{ created: N, errors: [...] }`
- Dla bulk, jesli URL jest duplikatem (facebook_url juz istnieje w DB — nie UNIQUE constraint w DB, wiec sprawdz recznie lub zignoruj i pozwol duplikatom — lepiej: dodaj walidacje pre-insert sprawdzajac istniejace URLe)

**2. `src/app/api/fb-groups/[id]/route.ts` — GET + PATCH + DELETE**

GET:
- `verifyAdmin()` guard
- SELECT explicite kolumny (bez cookies_encrypted) + `.eq('id', id).is('deleted_at', null).single()`
- 404 jesli nie znaleziono
- Wzbogac o `relevant_posts` i `has_custom_cookies`

PATCH:
- `verifyAdmin()` guard
- Body: Partial update — dozwolone pola: `name, facebook_url, developer, status, ai_instruction, cookies_encrypted`
- Jesli `cookies_encrypted` przychodzi jako plain text string — zaszyfruj przez `encrypt()` przed zapisem
- Jesli `cookies_encrypted` przychodzi jako `null` — ustaw NULL (usun override)
- Jesli `apify_actor_id` jest w body — sprawdz super admin (porownaj user.email z 'dariusz.ciesielski.71@gmail.com'), 403 jesli nie super admin
- Walidacja: `facebook_url` jesli podany musi byc valid FB group URL
- Zwroc zaktualizowany rekord (bez cookies_encrypted)

DELETE:
- `verifyAdmin()` guard
- Soft delete: `.update({ deleted_at: new Date().toISOString() }).eq('id', id)`
- Sprawdz czy grupa istnieje i nie jest juz deleted, 404 jesli nie
- Zwroc `{ success: true }`

**3. `src/app/api/fb-groups/developers/route.ts` — GET**

- `verifyAdmin()` guard
- `SELECT DISTINCT developer FROM fb_groups WHERE developer IS NOT NULL AND deleted_at IS NULL`
- W Supabase: `.from('fb_groups').select('developer').not('developer', 'is', null).is('deleted_at', null)`
- Deduplikuj w JS: `[...new Set(data.map(r => r.developer).filter(Boolean))]`
- Zwroc posortowana tablice stringow: `string[]`

**Helper: walidacja URL grupy FB (dodaj na gorze route.ts)**
```typescript
function isValidFbGroupUrl(url: string): boolean {
  try {
    const parsed = new URL(url);
    return (
      (parsed.hostname === 'www.facebook.com' || parsed.hostname === 'facebook.com' || parsed.hostname === 'm.facebook.com') &&
      parsed.pathname.includes('/groups/')
    );
  } catch {
    return false;
  }
}
```
  </action>
  <verify>
`npx tsc --noEmit` — zero bledow. Sprawdz ze kazdy plik:
- Importuje z `@/lib/api/admin`
- Zawiera `verifyAdmin()` guard
- Uzywa `.is('deleted_at', null)` w kazdym SELECT
- NIE zwraca `cookies_encrypted` w response
  </verify>
  <done>3 pliki API routes istnieja: fb-groups/route.ts (GET list + POST single/bulk), fb-groups/[id]/route.ts (GET + PATCH + DELETE soft), fb-groups/developers/route.ts (GET distinct). Wszystkie uzywaja verifyAdmin, filtruja soft-deleted, nie zwracaja encrypted danych.</done>
</task>

<task type="auto">
  <name>Task 2: API routes — bulk operations + fb-settings</name>
  <files>
    src/app/api/fb-groups/bulk/route.ts
    src/app/api/fb-settings/route.ts
  </files>
  <action>
Utworz 2 pliki API routes:

**1. `src/app/api/fb-groups/bulk/route.ts` — PATCH**

- `verifyAdmin()` guard
- Body: `{ ids: string[], action: 'set_status' | 'set_developer' | 'soft_delete', value?: string }`
- Walidacja: `ids` required i non-empty, `action` required
- Implementacja:
  - `set_status`: `.update({ status: value }).in('id', ids)` — value musi byc 'active' lub 'paused'
  - `set_developer`: `.update({ developer: value || null }).in('id', ids)`
  - `soft_delete`: `.update({ deleted_at: new Date().toISOString() }).in('id', ids)`
- WAZNE: Uzywaj JEDNEGO `.in('id', ids)` zamiast petli — atomowa operacja
- Zwroc `{ success: true, updated: ids.length }`
- Error handling: 400 dla blednych danych, 500 dla DB errors

**2. `src/app/api/fb-settings/route.ts` — GET + POST**

GET:
- `verifyAdmin()` guard
- Pobierz WSZYSTKIE ustawienia z fb_settings
- NIGDY nie zwracaj `value_encrypted` do klienta
- Zamiast tego zwroc obiekt z flagami boolean:
  ```json
  {
    "has_apify_token": true/false,
    "has_fb_cookies": true/false,
    "apify_actor_id": "curious_coder/facebook-post-scraper",
    "developer_instructions": { "Deweloper A": "instrukcja...", "Deweloper B": "..." }
  }
  ```
- `has_apify_token`: czy istnieje rekord z key='apify_token' i value_encrypted is not null
- `has_fb_cookies`: czy istnieje rekord z key='fb_cookies' i value_encrypted is not null
- `apify_actor_id`: value_plain z rekordu key='apify_actor_id' (lub default 'curious_coder/facebook-post-scraper')
- `developer_instructions`: zbierz wszystkie klucze pasujace do 'developer_instruction:*' i zwroc jako obiekt {nazwa_dewelopera: instrukcja}

POST:
- `verifyAdmin()` guard
- Body: `{ key: string, value: string }` — jedno ustawienie naraz
- Logika:
  - Jesli key to 'apify_token' lub 'fb_cookies': `encrypt(value)` i zapisz w `value_encrypted`, ustaw `value_plain = null`
  - Jesli key to 'apify_actor_id': sprawdz super admin (user.email === 'dariusz.ciesielski.71@gmail.com'), 403 jesli nie. Zapisz w `value_plain`.
  - Jesli key zaczyna sie od 'developer_instruction:': zapisz w `value_plain`
  - Inne klucze: 400 error
- Uzyj UPSERT: `.upsert({ key, value_encrypted, value_plain, updated_at: new Date().toISOString() }, { onConflict: 'key' })`
- Zwroc `{ success: true }`

**Super admin helper (wspoldzielony miedzy route.ts):**
```typescript
import { createClient as createServerClient } from '@/lib/supabase/server';
const SUPER_ADMIN_EMAIL = 'dariusz.ciesielski.71@gmail.com';

async function isSuperAdmin(): Promise<boolean> {
  const supabase = await createServerClient();
  const { data: { user } } = await supabase.auth.getUser();
  return user?.email === SUPER_ADMIN_EMAIL;
}
```
Umies tego helpera w fb-settings/route.ts (tam jest uzywany najczesciej). W fb-groups/[id]/route.ts mozesz go zduplikowac lub zaimportowac — pragmatyczne podejscie, nie overengineeruj.
  </action>
  <verify>
`npx tsc --noEmit` — zero bledow. Sprawdz ze:
- bulk/route.ts uzywa `.in('id', ids)` (nie petli)
- fb-settings GET NIE zwraca value_encrypted (tylko boolean flagi)
- fb-settings POST szyfruje tokeny/cookies przez encrypt()
- fb-settings POST sprawdza super admin przy zmianie apify_actor_id
  </verify>
  <done>2 pliki API: fb-groups/bulk/route.ts (PATCH z 3 akcjami bulk), fb-settings/route.ts (GET flagi + POST upsert z szyfrowaniem). Bulk uzywa atomowego .in(), settings nie wycieka encrypted danych, super admin gate na actor ID.</done>
</task>

</tasks>

<verification>
- [ ] 5 plikow API route istnieje w src/app/api/
- [ ] Kazdy plik importuje z @/lib/api/admin
- [ ] Kazdy GET/PATCH/DELETE na fb_groups filtruje `.is('deleted_at', null)`
- [ ] GET fb-groups NIE zwraca cookies_encrypted
- [ ] GET fb-settings zwraca boolean flagi, NIE encrypted values
- [ ] POST fb-settings szyfruje apify_token i fb_cookies
- [ ] PATCH fb-groups/bulk uzywa `.in('id', ids)`
- [ ] Zmiana apify_actor_id wymaga super admin
- [ ] `npx tsc --noEmit` przechodzi
</verification>

<success_criteria>
1. Wszystkie 5 endpointow odpowiadaja poprawnie (verifyAdmin guard, prawidlowe kody HTTP)
2. Encrypted dane NIGDY nie wyciekaja do klienta
3. Bulk operations sa atomowe (jeden query, nie petla)
4. Super admin gate dziala na apify_actor_id
</success_criteria>

<output>
After completion, create `.planning/phases/08-group-management/08-02-SUMMARY.md`
</output>
