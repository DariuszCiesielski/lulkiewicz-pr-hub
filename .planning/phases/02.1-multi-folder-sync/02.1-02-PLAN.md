---
phase: 02.1-multi-folder-sync
plan: 02
type: execute
wave: 1
depends_on: ["02.1-01"]
files_modified:
  - src/lib/email/email-parser.ts
  - src/app/api/sync/process/route.ts
  - src/app/api/sync/route.ts
autonomous: true

must_haves:
  truths:
    - "mapGraphMessageToEmail zwraca folder_id z msg.parentFolderId"
    - "sync/process route używa fetchMessagesPage z /messages (all-folders)"
    - "sync/process route filtruje excluded folders w każdym batchu"
    - "sync/process route dla delta sync używa fetchMessagesSince z last_sync_at"
    - "sync/route.ts nie wymaga delta_link do uruchomienia delta sync"
  artifacts:
    - path: "src/lib/email/email-parser.ts"
      provides: "Parser z folder_id"
      exports: ["mapGraphMessageToEmail"]
    - path: "src/app/api/sync/process/route.ts"
      provides: "Batch processing z all-folders i excluded folders filtering"
    - path: "src/app/api/sync/route.ts"
      provides: "Job creation bez wymagania delta_link"
---

<objective>
Adaptacja Sync API routes i email-parser do multi-folder sync. Po tym planie synchronizacja będzie pobierać maile ze wszystkich folderów (poza spam/drafts/deleted).

Purpose: Po tym planie użytkownik może uruchomić "Synchronizuj" i pobrać maile ze WSZYSTKICH folderów.
Output: Zaktualizowane 3 pliki — parser, sync/process, sync/route.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02.1-multi-folder-sync/02.1-CONTEXT.md
@src/lib/email/email-parser.ts
@src/lib/email/email-fetcher.ts
@src/lib/email/graph-folders.ts
@src/app/api/sync/process/route.ts
@src/app/api/sync/route.ts
@src/types/email.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: email-parser.ts — dodanie folder_id</name>
  <files>src/lib/email/email-parser.ts</files>
  <action>
W funkcji `mapGraphMessageToEmail`, dodaj pole `folder_id` do zwracanego obiektu:

```typescript
return {
  // ... istniejące pola bez zmian ...
  folder_id: msg.parentFolderId || null,  // NOWE: ID folderu źródłowego
};
```

Dodaj to pole na końcu obiektu return, przed zamykającym `};`.

Opcjonalnie: dodaj `folder_id` do interfejsu `Email` w `src/types/email.ts` jeśli nie ma:
```typescript
folder_id?: string | null;
```
  </action>
  <verify>
`npx tsc --noEmit` — zero błędów. Sprawdź że mapGraphMessageToEmail zawiera folder_id.
  </verify>
  <done>Parser zwraca folder_id z msg.parentFolderId.</done>
</task>

<task type="auto">
  <name>Task 2: sync/route.ts — usunięcie wymagania delta_link</name>
  <files>src/app/api/sync/route.ts</files>
  <action>
W pliku `src/app/api/sync/route.ts` znajdź logikę walidacji delta sync.

Obecna logika prawdopodobnie sprawdza czy `mailbox.delta_link` istnieje i zwraca błąd jeśli nie.

**Zmień** tę walidację:
- Delta sync NIE wymaga już delta_link
- Zamiast tego wymaga `mailbox.last_sync_at` (musi być co najmniej jedna pełna synchronizacja)
- Jeśli `last_sync_at` jest null, zwróć błąd: "Najpierw wykonaj pełną synchronizację"

Zachowaj resztę logiki tworzenia sync_jobs bez zmian.
  </action>
  <verify>
Sprawdź że delta sync job można stworzyć bez delta_link (potrzebny tylko last_sync_at).
  </verify>
  <done>sync/route.ts nie wymaga delta_link, wymaga last_sync_at dla delta sync.</done>
</task>

<task type="auto">
  <name>Task 3: sync/process/route.ts — adaptacja do multi-folder</name>
  <files>src/app/api/sync/process/route.ts</files>
  <action>
To jest główna zmiana. Zaktualizuj `src/app/api/sync/process/route.ts`:

**3a. Dodaj import:**
```typescript
import { getExcludedFolderIds } from '@/lib/email/graph-folders';
import {
  fetchMessagesPage,
  fetchMessagesSince,  // NOWE: zamiast fetchDeltaPage
  upsertEmails,
  getMailboxMessageCount,
  filterExcludedFolders,  // NOWE: filtrowanie excluded folders
} from '@/lib/email/email-fetcher';
```
Usuń import `fetchDeltaPage`.

**3b. Pobierz excluded folder IDs na początku batcha (po uzyskaniu graphClient):**

Po linii `const graphClient = createGraphClient(accessToken);`:

```typescript
// Get excluded folder IDs (cached in job metadata for subsequent batches)
let excludedFolderIds: string[] = [];
const jobMetadata = job.metadata as { excludedFolderIds?: string[] } | null;

if (jobMetadata?.excludedFolderIds) {
  // Reuse from previous batch
  excludedFolderIds = jobMetadata.excludedFolderIds;
} else {
  // First batch — fetch from Graph API and cache in job metadata
  try {
    excludedFolderIds = await getExcludedFolderIds(graphClient, mailbox.email_address);
    await adminClient
      .from('sync_jobs')
      .update({ metadata: { excludedFolderIds } })
      .eq('id', jobId);
  } catch {
    console.warn('Could not fetch excluded folders — syncing all folders');
  }
}
```

**3c. Zmień sekcję full sync — dodaj filtrowanie:**

Po `const parsed = result.messages.map(...)`:
```typescript
// Filter out excluded folders (spam, drafts, deleted items)
const filteredMessages = filterExcludedFolders(result.messages, excludedFolderIds);
const parsed = filteredMessages.map((msg) =>
  mapGraphMessageToEmail(msg, mailbox.id)
);
```

**3d. Zmień sekcję delta sync — użyj fetchMessagesSince zamiast fetchDeltaPage:**

Zastąp CAŁĄ sekcję `else { // Delta sync ... }` na:

```typescript
} else {
  // Delta sync — fetch messages since last sync date (all folders)
  const sinceDate = mailbox.last_sync_at || new Date(0).toISOString();

  const result = await fetchMessagesSince(
    graphClient,
    mailbox.email_address,
    sinceDate,
    job.page_token
  );

  // Filter out excluded folders
  const filteredMessages = filterExcludedFolders(result.messages, excludedFolderIds);
  const parsed = filteredMessages.map((msg) =>
    mapGraphMessageToEmail(msg, mailbox.id)
  );

  if (parsed.length > 0) {
    fetchedCount = await upsertEmails(adminClient, mailbox.id, parsed);
  }

  newPageToken = result.nextLink;
}
```

**3e. Usuń logikę zapisywania/odczytywania delta_link:**
- Usuń `newDeltaLink` zmienną
- Usuń `if (newDeltaLink) { mailboxUpdate.delta_link = newDeltaLink; }` z sekcji completed
- Nie usuwaj kolumny delta_link z mailboxes — po prostu nie używaj

**3f. Dodaj `delta_link` do select mailboxa** — zmień na `last_sync_at`:
W query pobierającym mailbox, zamień `delta_link` na `last_sync_at`:
```typescript
.select('id, email_address, connection_type, credentials_encrypted, tenant_id, client_id, last_sync_at')
```

WAŻNE: Zachowaj istniejącą logikę:
- Safety timeout (50s)
- Error handling (429 throttling, Graph API errors)
- Job status updates (processing → has_more → completed)
- Mailbox status updates on completion (sync_status, last_sync_at, total_emails)
  </action>
  <verify>
`npx tsc --noEmit` — zero błędów kompilacji.
Sprawdź że:
- fetchDeltaPage NIE jest importowany
- fetchMessagesSince JEST importowany i używany
- filterExcludedFolders jest wywoływany w obu ścieżkach (full + delta)
- excludedFolderIds jest cachowany w job.metadata
- delta_link nie jest już zapisywany ani odczytywany
  </verify>
  <done>sync/process route używa all-folders endpoints z filtrowaniem. Delta sync oparty na dacie zamiast delta_link.</done>
</task>

</tasks>

<verification>
- [ ] email-parser zwraca folder_id
- [ ] sync/route.ts akceptuje delta sync bez delta_link
- [ ] sync/process używa /messages (nie /mailFolders/inbox/messages)
- [ ] Excluded folders pobierane z Graph API i cachowane w job.metadata
- [ ] Delta sync używa fetchMessagesSince z $filter po dacie
- [ ] filterExcludedFolders wywoływany w obu ścieżkach
- [ ] delta_link nie jest zapisywany/odczytywany
- [ ] `npx tsc --noEmit` przechodzi bez błędów
</verification>

<success_criteria>
1. Pełna synchronizacja pobiera maile ze WSZYSTKICH folderów (bez spam/drafts/deleted)
2. Delta synchronizacja używa filtru po dacie (nie delta_link)
3. Excluded folders cachowane między batchami (1 API call per sync, nie per batch)
4. Kompilacja TypeScript bez błędów
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-multi-folder-sync/02.1-02-SUMMARY.md`
</output>
