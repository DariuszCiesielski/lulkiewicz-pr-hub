---
phase: 01-hub-shell-fundament
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/types/index.ts
  - src/contexts/AuthContext.tsx
  - src/app/api/admin/users/route.ts
  - src/app/api/admin/create-user/route.ts
  - src/app/(hub)/admin/page.tsx
  - src/app/(hub)/admin/layout.tsx
  - src/components/admin/UserList.tsx
  - src/components/admin/UserForm.tsx
  - src/components/admin/ToolAccessSelector.tsx
autonomous: true

must_haves:
  truths:
    - "Admin widzi panel admina z lista uzytkownikow"
    - "Admin moze dodac nowego uzytkownika (email + haslo tymczasowe lub zaproszenie)"
    - "Admin moze edytowac role uzytkownika (admin/user)"
    - "Admin moze kontrolowac dostep uzytkownika do narzedzi"
    - "Zwykly user nie widzi panelu admina (redirect lub brak linku)"
  artifacts:
    - path: "src/app/(hub)/admin/page.tsx"
      provides: "Strona panelu admina"
      min_lines: 30
    - path: "src/components/admin/UserList.tsx"
      provides: "Tabela uzytkownikow z akcjami edycji/usuwania"
      min_lines: 50
    - path: "src/components/admin/UserForm.tsx"
      provides: "Modal dodawania/edycji uzytkownika"
      min_lines: 60
    - path: "src/app/api/admin/create-user/route.ts"
      provides: "API route do tworzenia uzytkownikow (SUPABASE_SERVICE_ROLE_KEY)"
      exports: ["POST"]
    - path: "src/app/api/admin/users/route.ts"
      provides: "API route CRUD uzytkownikow"
      exports: ["GET", "PUT", "DELETE"]
  key_links:
    - from: "src/app/(hub)/admin/page.tsx"
      to: "src/app/api/admin/users/route.ts"
      via: "fetch /api/admin/users"
      pattern: "fetch.*api/admin/users"
    - from: "src/components/admin/UserForm.tsx"
      to: "src/app/api/admin/create-user/route.ts"
      via: "fetch /api/admin/create-user"
      pattern: "fetch.*api/admin/create-user"
    - from: "src/contexts/AuthContext.tsx"
      to: "app_allowed_users table"
      via: "Supabase query for role"
      pattern: "app_allowed_users"
---

<objective>
System rol admin/user + panel admina do zarzadzania uzytkownikami i kontroli dostepu do narzedzi.

Purpose: Tylko admin moze zarzadzac uzytkownikami i decydowac kto ma dostep do jakich narzedzi. Bez tego kazdy moze wszystko.
Output: Tabela app_allowed_users w Supabase, API routes do CRUD uzytkownikow, panel admina z lista/formularzem, AuthContext zaktualizowany o role i allowed_tools.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\dariu\Documents\Cursor projects\Lulkiewicz PR Hub\.planning\PROJECT.md
@C:\Users\dariu\Documents\Cursor projects\Lulkiewicz PR Hub\.planning\ROADMAP.md
@C:\Users\dariu\Documents\Cursor projects\Lulkiewicz PR Hub\.planning\phases\01-hub-shell-fundament\01-01-SUMMARY.md

Globalne skille (adaptuj do Next.js App Router):
@C:\Users\dariu\.claude\skills\user-management-system\SKILL.md
@C:\Users\dariu\.claude\skills\supabase-auth-rls\SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tabela Supabase + RLS + aktualizacja AuthContext</name>
  <files>
    src/types/index.ts
    src/contexts/AuthContext.tsx
  </files>
  <action>
    1. Utworz tabele w Supabase przez Management API (Supabase CLI broken — patrz STATE.md).
       Uzyj curl do Supabase Management API:

       ```sql
       -- Tabela dozwolonych uzytkownikow z rolami
       CREATE TABLE IF NOT EXISTS app_allowed_users (
         id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
         email TEXT UNIQUE NOT NULL,
         user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
         role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('admin', 'user')),
         allowed_tools TEXT[] DEFAULT '{}',
         display_name TEXT,
         created_at TIMESTAMPTZ DEFAULT NOW(),
         updated_at TIMESTAMPTZ DEFAULT NOW()
       );

       -- Trigger aktualizacji updated_at
       CREATE OR REPLACE FUNCTION update_updated_at_column()
       RETURNS TRIGGER AS $$
       BEGIN
         NEW.updated_at = NOW();
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql;

       CREATE TRIGGER update_app_allowed_users_updated_at
         BEFORE UPDATE ON app_allowed_users
         FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

       -- RLS
       ALTER TABLE app_allowed_users ENABLE ROW LEVEL SECURITY;

       -- SECURITY DEFINER function — unika rekurencji RLS
       CREATE OR REPLACE FUNCTION public.is_admin()
       RETURNS BOOLEAN AS $$
       BEGIN
         RETURN EXISTS (
           SELECT 1 FROM public.app_allowed_users
           WHERE user_id = auth.uid() AND role = 'admin'
         );
       END;
       $$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

       GRANT EXECUTE ON FUNCTION public.is_admin() TO authenticated;
       GRANT EXECUTE ON FUNCTION public.is_admin() TO anon;

       -- Policies
       CREATE POLICY "Users can read own record" ON app_allowed_users
         FOR SELECT USING (user_id = auth.uid());

       CREATE POLICY "Admins can do everything" ON app_allowed_users
         FOR ALL USING (public.is_admin());

       -- Dodaj pierwszego admina (wlasciciel):
       -- Po rejestracji konta, znajdz user_id i:
       -- INSERT INTO app_allowed_users (email, user_id, role, display_name)
       -- VALUES ('EMAIL_ADMINA', 'USER_UUID', 'admin', 'Administrator');
       ```

       Wykonaj SQL przez Supabase Management API:
       ```bash
       curl -X POST "https://api.supabase.com/v1/projects/{SUPABASE_PROJECT_REF}/database/query" \
         -H "Authorization: Bearer {SUPABASE_ACCESS_TOKEN}" \
         -H "Content-Type: application/json" \
         -d '{"query": "SQL_TUTAJ"}'
       ```

       UWAGA: Projekt Supabase dla Lulkiewicz PR Hub musi byc NAJPIERW utworzony (w planie 01-01 lub recznie).
       Ref i klucze beda dostepne po utworzeniu — uzyj wartosci z .env.local.

       WAZNE: Jesli projekt Supabase jeszcze nie istnieje (STATUS: TBD w STATE.md), NAJPIERW go utworz przez Management API z region `eu-central-1` (Frankfurt, GDPR):
       ```bash
       curl -X POST "https://api.supabase.com/v1/projects" \
         -H "Authorization: Bearer {SUPABASE_ACCESS_TOKEN}" \
         -H "Content-Type: application/json" \
         -d '{
           "name": "lulkiewicz-pr-hub",
           "organization_id": "{SUPABASE_ORG_ID}",
           "region": "eu-central-1",
           "plan": "free",
           "db_pass": "WYGENERUJ_SILNE_HASLO"
         }'
       ```
       Po utworzeniu: pobierz URL i klucze z odpowiedzi API i zaktualizuj .env.local.

    2. Zaktualizuj `src/types/index.ts` — dodaj interfejsy:
       ```typescript
       export interface AllowedUser {
         id: string;
         email: string;
         user_id: string | null;
         role: UserRole;
         allowed_tools: ToolId[];
         display_name: string | null;
         created_at: string;
         updated_at: string;
       }

       export interface UserFormData {
         email: string;
         displayName: string;
         role: UserRole;
         allowedTools: ToolId[];
         method: 'invite' | 'password';
         password?: string;
       }
       ```

    3. Zaktualizuj `src/contexts/AuthContext.tsx`:
       - Dodaj: userRole (UserRole | null), allowedTools (ToolId[]), isAdmin (boolean), hasAccess (boolean)
       - Po zalogowaniu: pobierz rekord z app_allowed_users dla user.email
       - canAccessTool(toolId): admin -> true, user -> allowedTools.includes(toolId)
       - refreshPermissions(): ponowne pobranie roli/narzedzi
       - Jesli user nie jest w tabeli app_allowed_users -> hasAccess = false

    WAZNE:
    - NIE uzywaj Edge Functions (Supabase CLI broken) — uzyj Next.js API routes
    - Wzorzec z globalnego skill user-management-system, zaadaptowany do Next.js
    - SECURITY DEFINER na is_admin() aby uniknac rekurencji RLS
    - ON DELETE SET NULL na user_id (nie CASCADE) — zachowaj rekord nawet po usunieciu auth user
  </action>
  <verify>
    - SQL wykonany bez bledow (sprawdz odpowiedz API)
    - `SELECT * FROM app_allowed_users;` zwraca pusta tabele (lub z pierwszym adminem)
    - `SELECT public.is_admin();` dziala (zwraca false dla nowego usera)
    - `npm run build` przechodzi z zaktualizowanym AuthContext
  </verify>
  <done>
    Tabela app_allowed_users istnieje z RLS, is_admin() SECURITY DEFINER dziala, AuthContext pobiera role i allowed_tools po zalogowaniu.
  </done>
</task>

<task type="auto">
  <name>Task 2: API routes + panel admina UI</name>
  <files>
    src/app/api/admin/users/route.ts
    src/app/api/admin/create-user/route.ts
    src/app/(hub)/admin/page.tsx
    src/app/(hub)/admin/layout.tsx
    src/components/admin/UserList.tsx
    src/components/admin/UserForm.tsx
    src/components/admin/ToolAccessSelector.tsx
  </files>
  <action>
    1. Utworz `src/app/api/admin/users/route.ts`:
       - GET: Pobierz liste uzytkownikow z app_allowed_users (wymaga admina)
       - PUT: Aktualizuj role/allowed_tools/display_name uzytkownika (wymaga admina)
       - DELETE: Usun uzytkownika z app_allowed_users (wymaga admina)
       - Weryfikacja admina: uzyj createServerClient + is_admin() RPC
       - Uzyj SUPABASE_SERVICE_ROLE_KEY do operacji admin (service role client)

    2. Utworz `src/app/api/admin/create-user/route.ts`:
       - POST: Tworzenie nowego uzytkownika
       - Metoda "password": createUser z email + haslo (supabase.auth.admin.createUser)
       - Metoda "invite": inviteUserByEmail (supabase.auth.admin.inviteUserByEmail)
       - Po utworzeniu auth user: INSERT do app_allowed_users (email, user_id, role, allowed_tools, display_name)
       - Sprawdz czy user juz istnieje w auth.users (listUsers + filtracja po email)
       - Uzyj service role client (SUPABASE_SERVICE_ROLE_KEY) — auth.admin wymaga service role
       - Weryfikacja: caller musi byc adminem

    3. Utworz `src/app/(hub)/admin/layout.tsx`:
       - Prosty wrapper — sprawdz isAdmin z useAuth(), jesli nie admin -> redirect na /dashboard
       - "use client"

    4. Utworz `src/components/admin/ToolAccessSelector.tsx`:
       - Lista 6 narzedzi (z types.ts ToolId) z checkboxami
       - Nazwy po polsku: "Analizator Email", "Narzedzie 2", ..., "Narzedzie 6"
       - "Zaznacz wszystkie" / "Odznacz wszystkie" linki
       - Styl: wzorzec z globalnego skill user-management-system, adaptacja do CSS variables

    5. Utworz `src/components/admin/UserForm.tsx`:
       - Modal z formularzem (overlay + card)
       - Pola: email, nazwa wyswietlana, rola (select admin/user), metoda (radio: zaproszenie/haslo)
       - Jesli rola == 'user': pokaz ToolAccessSelector
       - Jesli metoda == 'password': pokaz pole hasla tymczasowego
       - Tryb edycji: email disabled, brak metody tworzenia
       - Submit: POST do /api/admin/create-user (nowy) lub PUT do /api/admin/users (edycja)
       - Styl: "jasna wyspa" (bg-white w ciemnym overlay) — jak w SKILL.md

    6. Utworz `src/components/admin/UserList.tsx`:
       - Tabela: Uzytkownik (email + display_name), Rola (badge admin/user), Narzedzia (liczba lub "Pelny dostep"), Akcje (edytuj/usun)
       - Loading state, empty state
       - Potwierdzenie przed usunieciem (window.confirm)
       - Styl: CSS variables dla integracji z motywem

    7. Utworz `src/app/(hub)/admin/page.tsx`:
       - "use client"
       - Tytul: "Zarzadzanie uzytkownikami" z ikona Users
       - Przycisk "Dodaj uzytkownika" + "Odswiez"
       - Fetch uzytkownikow z /api/admin/users na uzyciu useEffect
       - Renderuj UserList + UserForm (modal)
       - Error handling z wyswietleniem komunikatu

    WAZNE:
    - API routes uzyj createClient z @supabase/supabase-js (service role) — NIE @supabase/ssr dla admin operations
    - Weryfikacja admina w API: pobierz sesje z request cookies, sprawdz is_admin() via RPC
    - Jezyk: TYLKO polski (etykiety, przyciski, komunikaty)
    - Styl panelu admina: wzorzec "pelnej integracji" z CSS variables (var(--bg-secondary), var(--text-primary) itd.)
    - Formularze w modalu: wzorzec "jasnej wyspy" (bg-white, text-slate-900)
  </action>
  <verify>
    - `npm run build` przechodzi bez bledow
    - API GET /api/admin/users zwraca 200 z lista (pusta lub z adminem)
    - API POST /api/admin/create-user tworzy uzytkownika (test z curl)
    - Panel admina /admin renderuje tabele uzytkownikow
    - Modal dodawania uzytkownika otwiera sie i zamyka
    - Niezalogowany user -> redirect z /admin na /login
    - Zalogowany user (nie admin) -> redirect z /admin na /dashboard
  </verify>
  <done>
    Panel admina dziala: admin widzi liste uzytkownikow, moze dodawac (email invite lub haslo tymczasowe), edytowac role (admin/user), kontrolowac dostep do narzedzi. Requirements HUB-04, HUB-05 spelnione.
  </done>
</task>

</tasks>

<verification>
- Admin moze zalogowac sie i przejsc do /admin
- Admin widzi tabele uzytkownikow (nawet jesli pusta)
- Admin moze dodac nowego uzytkownika (oba tryby: invite i haslo)
- Admin moze edytowac role i narzedzia istniejacego uzytkownika
- Admin moze usunac uzytkownika
- Zwykly user nie ma dostepu do /admin
- `npm run build` przechodzi
</verification>

<success_criteria>
1. Tabela app_allowed_users istnieje w Supabase z RLS
2. is_admin() SECURITY DEFINER function dziala
3. API routes CRUD uzytkownikow dzialaja
4. Panel admina renderuje liste uzytkownikow
5. Dodawanie/edycja/usuwanie uzytkownikow dziala
6. AuthContext zwraca poprawna role i allowed_tools
7. Niezalogowani i nie-admini nie maja dostepu do /admin
</success_criteria>

<output>
Po zakonczeniu utworz `.planning/phases/01-hub-shell-fundament/01-02-SUMMARY.md`
</output>
